<!DOCTYPE html>
<html lang="en" data-bs-theme="light">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        <meta name="author" content="LLNL">
        <link rel="canonical" href="https://software.llnl.gov/quandary/user_guide/">
        <link rel="shortcut icon" href="../img/favicon.ico">
        <title>User Guide - Quandary</title>
        <link href="../css/bootstrap.min.css" rel="stylesheet">
        <link href="../css/fontawesome.min.css" rel="stylesheet">
        <link href="../css/brands.min.css" rel="stylesheet">
        <link href="../css/solid.min.css" rel="stylesheet">
        <link href="../css/v4-font-face.min.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">
        <link id="hljs-light" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" >
        <link id="hljs-dark" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css" disabled>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
        <script>hljs.highlightAll();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="..">Quandary</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-bs-toggle="collapse" data-bs-target="#navbar-collapse" aria-controls="navbar-collapse" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="nav-item">
                                <a href=".." class="nav-link">Home</a>
                            </li>
                            <li class="nav-item dropdown">
                                <a href="#" class="nav-link dropdown-toggle" role="button" data-bs-toggle="dropdown"  aria-expanded="false">Basics</a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../getting_started/" class="dropdown-item">Getting Started</a>
</li>
                                    
<li>
    <a href="../QuandaryWithPython_HowTo/" class="dropdown-item">Tutorial</a>
</li>
                                </ul>
                            </li>
                            <li class="nav-item">
                                <a href="./" class="nav-link active" aria-current="page">User Guide</a>
                            </li>
                            <li class="nav-item dropdown">
                                <a href="#" class="nav-link dropdown-toggle" role="button" data-bs-toggle="dropdown"  aria-expanded="false">Reference</a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../python_api/" class="dropdown-item">Python API Reference</a>
</li>
                                    
<li>
    <a href="../config/" class="dropdown-item">C++ Configuration Reference</a>
</li>
                                    
<li>
    <a href="https://software.llnl.gov/quandary/doxygen/" class="dropdown-item">Doxygen</a>
</li>
                                </ul>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ms-md-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-bs-toggle="modal" data-bs-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li class="nav-item">
                                <a rel="prev" href="../QuandaryWithPython_HowTo/" class="nav-link">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li class="nav-item">
                                <a rel="next" href="../python_api/" class="nav-link">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-bs-toggle="collapse" data-bs-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-body-tertiary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-bs-level="1"><a href="#quandary-optimal-control-for-open-and-closed-quantum-systems" class="nav-link">Quandary: Optimal Control for Open and Closed Quantum Systems</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="1"><a href="#introduction" class="nav-link">Introduction</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="1"><a href="#sec:model" class="nav-link">Model equation</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#rotational-frame" class="nav-link">Rotational frame</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#sec:essential" class="nav-link">Essential and non-essential energy levels</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#sec:controlpulses" class="nav-link">Control pulse parameterization</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="1"><a href="#sec:optim" class="nav-link">The Optimal Control Problem</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#sec:objectivefunctionals" class="nav-link">Objective function</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#sec:targets" class="nav-link">Optimization targets</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#sec:initcond" class="nav-link">Initial conditions</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#sec:penalty" class="nav-link">Regularization, penalty terms, and leakage prevention</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#optimization-algorithm" class="nav-link">Optimization algorithm</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="1"><a href="#implementation" class="nav-link">Implementation</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#real-valued-and-vectorized-formulation" class="nav-link">Real-valued and vectorized formulation</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#time-stepping" class="nav-link">Time-stepping</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#sparse-matrix-vs-matrix-free-solver" class="nav-link">Sparse-matrix vs. matrix-free solver</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#gradient-computation-via-discrete-adjoint-back-propagation" class="nav-link">Gradient computation via discrete adjoint back-propagation</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#storage-of-the-control-parameters" class="nav-link">Storage of the control parameters</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="1"><a href="#parallelization" class="nav-link">Parallelization</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="1"><a href="#output-and-plotting-the-results" class="nav-link">Output and plotting the results</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="1"><a href="#testing" class="nav-link">Testing</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="1"><a href="#acknowledgments" class="nav-link">Acknowledgments</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="1"><a href="#appendix-details-for-the-real-valued-system-matrices-standard-model" class="nav-link">Appendix: Details for the real-valued system matrices (standard model)</a>
              <ul class="nav flex-column">
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="quandary-optimal-control-for-open-and-closed-quantum-systems">Quandary: Optimal Control for Open and Closed Quantum Systems</h1>
<h1 id="introduction">Introduction</h1>
<p>Quandary numerically simulates and optimizes the time evolution of closed and open quantum systems. The
underlying dynamics are modelled by either Schroedinger's equation (for closed systems), or Lindblad's master equation (for open systems that interact with the environment). Quandary solves the respective ordinary differential equation (ODE) numerically by applying a time-stepping integration scheme, and applies a gradient-based optimization
scheme to determine optimal control pulses that drive the quantum system to a desired target.
The target can be a unitary, i.e. optimizing for pulses that
realize a logical quantum operation, or state preparation that aims to drive the quantum system from one (or multiple) initial state to a desired target state, such as for example the ground state of zero energy level, or for the creation of entangled states.</p>
<p>Quandary is designed to solve optimal control problems in larger (potentially open) quantum systems, targeting modern high performance computing (HPC) platforms. Quandary utilizes distributed memory computations using the message passing paradigm that enables scalability to large number of compute cores. Implemented in C++, Quandary is portable and its object-oriented implementation allows developers to extend the predefined setup to suit their particular simulation and optimization requirements. For example, customized gates for Hamiltonian simulations can easily be added to supplement Quandary’s predefined gate set.
The Python interface allows for greater flexibility where custom Hamiltonian models can be used.</p>
<p>This document outlines the mathematical background and underlying equations, and summarizes their
implementation and usage in Quandary. Also refer to publications <sup id="fnref:guenther2021quandary"><a class="footnote-ref" href="#fn:guenther2021quandary">1</a></sup> <sup id="fnref:guenther2021quantum"><a class="footnote-ref" href="#fn:guenther2021quantum">2</a></sup>.</p>
<h1 id="sec:model">Model equation</h1>
<p>Quandary models composite quantum systems consisting of <span class="arithmatex">\(Q\)</span> subsystems ("oscillators", "qubits"), with <span class="arithmatex">\(n_k\)</span> energy levels for the
<span class="arithmatex">\(k\)</span>-th subsystem, <span class="arithmatex">\(k=0,\dots,Q-1\)</span>. The Hilbert space dimension is <span class="arithmatex">\(N = \prod_{k=0}^{Q-1} n_k\)</span>.</p>
<p>For a <strong>closed quantum system</strong> (no environmental interactions), the quantum state is described by a complex-valued vector <span class="arithmatex">\(\psi\in\C^N\)</span>, with <span class="arithmatex">\(\|\psi\| = 1\)</span>. For a given initial state <span class="arithmatex">\(\psi(t=0)\)</span>, the evolution of the state vector is modelled through <strong>Schroedinger's equation</strong></p>
<pre class="arithmatex">\[\begin{align} \label{eq:schroedinger}
  \dot{\psi}(t)  = -i H(t) \psi(t)
\end{align}\]</pre>
<p>For <strong>open quantum systems</strong> (taking interactions with the environment into account), the quantum state is described by the density matrix <span class="arithmatex">\(\rho\in \C^{N\times N}\)</span> (hermitian, trace one, positive semi definite). In that case, Quandary models the the quantum dynamics via <strong>Lindblad's master equation</strong>:</p>
<pre class="arithmatex">\[\begin{align}\label{mastereq}
  \dot{\rho}(t) = &amp;-i(H(t)\rho(t) - \rho(t)H(t)) + \Ell(\rho(t)),
\end{align}\]</pre>
<p><em>Note:</em> In the remainder, the quantum state will mostly be denoted by <span class="arithmatex">\(\rho\)</span>, which, depending on the context, either relates to the density matrix solving Lindblad's equation, or to the state vector <span class="arithmatex">\(\psi\in \C^N\)</span> solving Schroedinger's equation. Distinction will only be made explicit where necessary.</p>
<p>The <strong>default Hamiltonian</strong> in Quandary models superconducting (transmon) qubits, decomposing the Hamiltonian matrix into a constant system part and a time-dependent control part that models the action of control fields applied to each subsystem:</p>
<pre class="arithmatex">\[\begin{align}
  H(t) = H_d + H_c(t) \quad \text{where} \quad
  H_d &amp;:= \sum_{k=0}^{Q-1} \omega_k a_k^{\dagger}a_k- \frac{\xi_k}{2} a_k^{\dagger}a_k^{\dagger}a_k a_k  + \sum_{l&gt; k} J_{kl} \left( a_k^\dagger a_l + a_k a_l^\dagger \right) - \sum_{l&gt; k}\xi_{kl} a_{k}^{\dagger}a_{k}   a_{l}^{\dagger} a_{l} \\
  H_c(t) &amp;:= \sum_{k=0}^{Q-1} f^k(t) \left(a_k + a_k^\dagger \right)
\end{align}\]</pre>
<p>where <span class="arithmatex">\(\omega_k\geq 0\)</span> denotes <span class="arithmatex">\(0 \rightarrow 1\)</span> transition frequencies for each oscillator <span class="arithmatex">\(k\)</span>, <span class="arithmatex">\(\xi_k\geq 0\)</span> are the self-Kerr coefficients. Couplings can be specified through the cross resonance coefficients <span class="arithmatex">\(J_{kl}\geq 0\)</span> ("dipole-dipole interaction") or through <span class="arithmatex">\(\xi_{kl}\geq 0\)</span> ("zz-coupling"). 
Here, <span class="arithmatex">\(a_k\in \C^{N\times N}\)</span> denotes the lowering operator acting on subsystem <span class="arithmatex">\(k\)</span>.
The control pulses <span class="arithmatex">\(f^k(t)\)</span> can be either specified or optimized for, compare section <a href="#sec:controlpulses">Control pulse parameterization</a>. <strong>Custom system and control Hamiltonian operators</strong> can be specified through Quandary's python interface.</p>
<p>The <strong>default Lindbladian</strong> operator <span class="arithmatex">\(\Ell(\rho(t))\)</span> is of the form</p>
<pre class="arithmatex">\[\begin{align} \label{eq:collapseop}
  \Ell(\rho(t)) = \sum_{k=0}^{Q-1} \sum_{l=1}^2 \Ell_{lk} \rho(t)
  \Ell_{lk}^{\dagger} - \frac 1 2 \left( \Ell_{lk}^{\dagger}\Ell_{lk}
  \rho(t) + \rho(t)\Ell_{lk}^{\dagger} \Ell_{lk}\right)
\end{align}\]</pre>
<p>where the collapse operators <span class="arithmatex">\(\Ell_{lk}\)</span> model decay and dephasing in each subsystem <span class="arithmatex">\(k\)</span> with</p>
<ul>
<li>Decay  ("<span class="arithmatex">\(T_1\)</span>"): <span class="arithmatex">\(\Ell_{1k} = \frac{1}{\sqrt{T_1^k}} a_k\)</span></li>
<li>Dephasing  ("<span class="arithmatex">\(T_2\)</span>"): <span class="arithmatex">\(\Ell_{2k} = \frac{1}{\sqrt{T_2^k}} a_k^{\dagger}a_k\)</span></li>
</ul>
<!-- Note that the main choice here is which equation should be solved for and which representation of the quantum state will be used (either Schroedinger with a state vector $\psi \in \C^N$, or Lindblad's equation for a density matrix $\rho \in \C^{N\times N}$). In the C++ configuration file, this choice is determined through the option `collapse_type`, where `none` will result in Schroedinger's equation and any other choice will result in Lindblad's equation being solved for. Further note, that choosing `collapse_type` $\neq$ `none`, together with a collapse time $T_{l}^k = 0.0$ will omit the evaluation of the corresponding term in the Lindblad operator $\eqref{eq:collapseop}$ (but will still solve Lindblad's equation for the density matrix). In the python interface, Lindblad's solver is enabled by passing decay and decoherence times `T1` and `T2` per oscillator to the Quandary object. -->

<h2 id="rotational-frame">Rotational frame</h2>
<p>Quandary uses the rotating wave approximation to slow down the time scale of the quantum dynamics. The user can specify the rotation frequencies <span class="arithmatex">\(\omega_k^r\)</span> for each oscillator. Under the rotating frame wave approximation, the Hamiltonians are transformed to</p>
<pre class="arithmatex">\[\begin{align}
  \tilde{H}_d(t) &amp;:= \sum_{k=0}^{Q-1} \left(\omega_k - \omega_k^{r}\right)a_k^{\dagger}a_k- \frac{\xi_k}{2}
  a_k^{\dagger}a_k^{\dagger}a_k a_k
   - \sum_{l&gt; k} \xi_{kl} a_{k}^{\dagger}a_{k}   a_{l}^{\dagger} a_{l} \notag \\
   &amp; + \sum_{l&gt;k} J_{kl} \cos(\eta_{kl}t) \left(a_k^\dagger a_l + a_k a_l^\dagger\right) + iJ_{kl} \sin(\eta_{kl}t)\left(a_k^\dagger a_l - a_k a_l^\dagger\right) \label{eq:Hd_rotating} \\
   %
   \tilde{H}_c(t) &amp;:= \sum_{k=0}^{Q-1} p^k(t) (a_k +
   a_k^{\dagger}) + i q^k(t)(a_k - a_k^{\dagger})
    \label{eq:Hc_rotating}
\end{align}\]</pre>
<p>where <span class="arithmatex">\(\eta_{kl} := \omega_k^{r} - \omega_l^{r}\)</span> are the differences in rotational frequencies between subsystems. Note that the dipole-dipole coupling is time-dependent if <span class="arithmatex">\(\eta_{kl} \neq 0\)</span>. Using the rotating wave approximation, the rotating-frame control pulses <span class="arithmatex">\(p^k(t)\)</span> and <span class="arithmatex">\(q^k(t)\)</span> relate to the laboratory frame control pulse through </p>
<pre class="arithmatex">\[\begin{align}
  f^k(t) = 2\mbox{Re}\left(d^k(t)e^{i\omega_k^r t}\right), \quad d^k(t) = p^k(t) + i q^k(t)
\end{align}\]</pre>
<h2 id="sec:essential">Essential and non-essential energy levels</h2>
<p>It is recommended to model the system with more energy levels than those that will be occupied during the dynamical evolution, in order to prevent leakage out of the computational subspace (modelling the infinite dimensional system with more accuracy by including more levels) and/or to allow the system to transition through higher energy levels in order to achieve a final-time target faster. In that case, <em>essential</em> levels, <span class="arithmatex">\(n_k^e\)</span>, denote the computational subspace, e.g. <span class="arithmatex">\(n_k^e = 2\)</span> for qubits, whereas the total number of energy levels <span class="arithmatex">\(n_k \geq n_k^e\)</span> could be larger, e.g. <span class="arithmatex">\(n_k=3\)</span>. Any non-essential level is considered a <em>guard</em> level.</p>
<h2 id="sec:controlpulses">Control pulse parameterization</h2>
<p>The time-dependent rotating-frame control pulses <span class="arithmatex">\(d^k(t) = p^k(t) + iq^k(t)\)</span> are parameterized using Bsplines with <span class="arithmatex">\(N_s^k\)</span> basis functions <span class="arithmatex">\(B_s(t)\)</span>, that act as an envelope for <span class="arithmatex">\(N_f^k\)</span> carrier waves:</p>
<pre class="arithmatex">\[\begin{align}\label{eq:spline-ctrl}
  d^k(\vec{\alpha}^k,t) = \sum_{f=1}^{N_f^k} e^{i\Omega^k_ft} \sum_{s=1}^{N_s^k} \alpha_{s,f}^k B_s(t) , \quad \alpha_{s,f}^k = \alpha_{s,f}^{k(1)} + i \alpha_{s,f}^{k(2)} \in \C
\end{align}\]</pre>
<p>Using trigonometric identities, the real and imaginary part of the rotating-frame control <span class="arithmatex">\(d^k(\vec{\alpha}^k,t) = p^k(\vec{\alpha}^k,t) + iq^k(\vec{\alpha}^k,t)\)</span> can be written as</p>
<pre class="arithmatex">\[\begin{align}
  p^k(\vec{\alpha}^k,t) &amp;= \sum_{f=1}^{N_f^k} \cos(\Omega_f^k t) B^{(1)}(t) 
    - \sin(\Omega_f^k t) B^{(2)}(t) \\
  q^k(\vec{\alpha}^k,t) &amp;= \sum_{f=1}^{N_f^k} \sin(\Omega_f^k t) B^{(1)}(t) + \cos(\Omega_f^k t)B^{(2)}(t) 
\end{align}\]</pre>
<p>where <span class="arithmatex">\(B^{(1)}(t) = \sum_{s=1}^{N_s^k} \alpha^{k(1)}_{s,f} B_s(t)\)</span> and <span class="arithmatex">\(B^{(2)}(t) = \sum_{s=1}^{N_s^k} \alpha^{k(2)}_{s,f} B_s(t)\)</span> evaluate the splines using the control coefficients <span class="arithmatex">\(\alpha_{f,s}^{k(1)}, \alpha_{f,s}^{k(2)}\in \R\)</span>. 
By default, the basis functions are piecewise quadratic B-spline polynomials with compact support, centered on an equally spaced grid in time. To instead use a piecewise constant (0th order) Bspline basis, see Section <a href="#sec:bspline-0">0-th order Bspline basis functions</a>.</p>
<p>The control parameter vector <span class="arithmatex">\(\boldsymbol{\alpha} = (\alpha_{f,s}^{k(i)})\)</span> (<em>design</em> variables) can be either specified (e.g. a constant pulse, a pi-pulse, or pulses whose parameters are read from a given file), or can be optimized for in order to realize a desired system behavior (Section <a href="#sec:optim">The Optimal Control Problem</a>).  </p>
<h3 id="carrier-wave-frequencies">Carrier wave frequencies</h3>
<p>The rotating-frame carrier wave frequencies <span class="arithmatex">\(\Omega^k_f \in \R\)</span> should be chosen to trigger intrinsic system resonance frequencies. For example, when <span class="arithmatex">\(\xi_{kl} &lt;&lt; \xi_k\)</span>, the intrinsic qubit transition frequencies are <span class="arithmatex">\(\omega_k - n\xi_k\)</span>. Thus by choosing <span class="arithmatex">\(\Omega^k_f = \omega_k-\omega_k^r - n \xi_k\)</span> in the rotating frame, one triggers transition between energy levels <span class="arithmatex">\(n\)</span> and <span class="arithmatex">\(n+1\)</span> in subsystem <span class="arithmatex">\(k\)</span>. Choosing effective carrier wave frequencies is quite important for optimization performance, particulary when qubit interactions are desired, such as when optimizing for a CNOT gate. Using the python interface for Quandary, the carrier wave frequencies <span class="arithmatex">\(\Omega^k_f\)</span> are automatically computed based on an eigenvalue decomposition of the system Hamiltonian. For the C++ code, it is recommended to follow <sup id="fnref:petersson2021optimal"><a class="footnote-ref" href="#fn:petersson2021optimal">3</a></sup> for details on how to choose them effectively.  </p>
<h3 id="alternative-control-parameterization-based-on-b-spline-amplitudes-and-time-constant-phases">Alternative control parameterization based on B-spline amplitudes and time-constant phases</h3>
<p>As an alternative parameterization, the user can choose to parameterize only the <em>amplitudes</em> of the control pulse with 2nd order B-splines, adding a time-constant phase per carrierwave:</p>
<pre class="arithmatex">\[\begin{align}
  d(t) = \sum_f e^{i\Omega_f t} a_f(t)e^{ib_f} \quad \text{where} \quad a_f(t) = \sum_s \alpha_{f,s} B_s(t) \\
  \Rightarrow d(t)= \sum_f\sum_s \alpha_{f,s}B_s(t)e^{i\Omega_ft + b_f}
\end{align}\]</pre>
<p>where the control parameters are <span class="arithmatex">\(b_f\in [-\pi, \pi]\)</span> (phases for each carrier wave) and the amplitudes <span class="arithmatex">\(\alpha_{f,s}\in \R\)</span> for <span class="arithmatex">\(s=1,\dots, N_s\)</span>, <span class="arithmatex">\(f=1,\dots, N_f\)</span>. Hence for <span class="arithmatex">\(Q\)</span> oscillators, we have a total of <span class="arithmatex">\(\sum_q (N_s^q + 1) N_f^q\)</span> control parameters.</p>
<h3 id="sec:bspline-0">Piecewise constant control parameterization (0-th order Bspline basis functions)</h3>
<p>Piecewise constant control pulses can be generated by using 0-th order Bspline basis functions. In this case, it is recommended to set the carrier wave frequencies to zero in the rotating frame. When optimizing with 0-th order B-spline basis functions, strong variations between consecutive control amplitudes can be suppressed by enabling the total variation penalty term, compare Section <a href="#sec:penalty">Regularization, penalty terms, and leakage prevention</a>.</p>
<h1 id="sec:optim">The Optimal Control Problem</h1>
<p>In the most general form, Quandary can solve the following optimization problem:</p>
<pre class="arithmatex">\[\begin{align}\label{eq:minproblem}
  \min_{\boldsymbol{\alpha}} J\left(\{\rho^{target}_i, \rho_i(T)\}\right) +  \mbox{Regularization} + \mbox{Penalty}
\end{align}\]</pre>
<p>where the (single or multiple) final-time states <span class="arithmatex">\(\rho_i(T)\)</span> solve either Lindblad's master equation <span class="arithmatex">\(\eqref{mastereq}\)</span> or Schroedinger's equation <span class="arithmatex">\(\eqref{eq:schroedinger}\)</span> in the rotating frame for (one or multiple) initial conditions <span class="arithmatex">\(\rho_i(0)\)</span>, as specified in Section <a href="#sec:initcond">Initial conditions</a>, <span class="arithmatex">\(i=1,\dots, n_{init}\)</span>. The first term in <span class="arithmatex">\(\eqref{eq:minproblem}\)</span> minimizes an objective function <span class="arithmatex">\(J\)</span> (see Section <a href="#sec:objectivefunctionals">Objective function</a>) that quantifies the discrepancy between the realized states <span class="arithmatex">\(\rho_i(T)\)</span> at final time <span class="arithmatex">\(T\)</span> driven by the current control <span class="arithmatex">\(\boldsymbol{\alpha}\)</span> and the desired target <span class="arithmatex">\(\rho^{target}_i\)</span>, see Section <a href="#sec:targets">Optimization targets</a>.
The remaining terms are regularization and penalty terms that can be added to stabilize convergence, or prevent leakage, compare Section <a href="#sec:penalty">Regularization, penalty terms, and leakage prevention</a></p>
<h2 id="sec:objectivefunctionals">Objective function</h2>
<p>The following objective functions can be used for optimization in Quandary (config option <code>optim_objective</code>):</p>
<pre class="arithmatex">\[\begin{align}
 J_{Frobenius} &amp;= \sum_{i=1}^{n_{init}} \frac{\beta_i}{2} \left\| \rho^{target}_i - \rho_i(T)\right\|^2_F \\
 J_{trace} &amp;=
\begin{cases}
 1 - \sum_{i=1}^{n_{init}} \frac{\beta_i}{w_i} \mbox{Tr}\left((\rho^{target}_i)^\dagger\rho_i(T)\right) &amp; \text{if Lindblad}\\
 1 - \left|\sum_{i=1}^{n_{init}} \beta_i (\psi^{target}_i)^\dagger\psi_i(T)\right|^2 &amp; \text{if Schroedinger}
\end{cases}\\
 J_{measure} &amp;= \sum_{i=1}^{n_{init}} \beta_i \mbox{Tr} \left( N_m \rho(T) \right) \label{eq:Jmeasure}
\end{align}\]</pre>
<p>for default weights default <span class="arithmatex">\(\beta_i = 1/n_{init}\)</span> that can be chosen to scale different contribution of each initial-to-target state.
<span class="arithmatex">\(J_{Frobenius}\)</span> measures (weighted average of) the Frobenius norm between target and final states. <span class="arithmatex">\(J_{Trace}\)</span> measures the (weighted) infidelity in terms of the Hilbert-Schmidt overlap. Here, <span class="arithmatex">\(w_i = \mbox{Tr}\left(\rho_i(0)^2\right)\)</span> is the purity of the initial state. Both measures are common for optimization towards a unitary gate transformation, for example. <span class="arithmatex">\(J_{measure}\)</span> is (only) useful when considering unconditional pure-state preparation, see Section <a href="#sec:targets">Optimization targets</a>. Here, <span class="arithmatex">\(m\in\N\)</span> is a given integer, and <span class="arithmatex">\(N_m\)</span> is a diagonal matrix with diagonal elements being <span class="arithmatex">\(|k-m|, k=0,\dots N-1\)</span></p>
<!-- The distinction for the Lindblad vs. Schroedinger solver is made explicit for $J_{trace}$ above. The other two measures apply naturally to either the density matrix version solving Lindblad's equation, or the state vector version solving Schroedinger's equation. -->

<h3 id="fidelity">Fidelity</h3>
<p>As a measure of optimization success, Quandary reports on the <strong>fidelity</strong> computed from</p>
<pre class="arithmatex">\[\begin{align}\label{eq:fidelity}
  F = \begin{cases}
    \frac{1}{n_{init}} \sum_{i=1}^{n_{init}} \mbox{Tr}\left(\left(\rho^{target}_i\right)^\dagger\rho_i(T) \right) &amp; \text{if Lindblad} \\
    \left|\frac{1}{n_{init}} \sum_{i=1}^{n_{init}} (\psi^{target}_i)^\dagger \psi_i(T) \right|^2 &amp; \text{if Schroedinger}
  \end{cases}
\end{align}\]</pre>
<p>The fidelity is an average of Hilbert-Schmidt overlaps of the target states and the evolved states: for the density matrix, the Hilbert-Schmidt overlap is <span class="arithmatex">\(\langle \rho^{target}, \rho(t)\rangle = \mbox{Tr}\left(\left(\rho^{target}\right)^\dagger\rho(T)\right)\)</span>, which is <em>real</em> if both states are density matrices (which is always the case in Quandary, see definition of basis matrices). For the state vector (and the Schroedinger solver), the Hilbert-Schmidt overlap is <span class="arithmatex">\(\langle \psi^{target}, \psi(T)\rangle = (\psi^{target})^{\dagger}\psi\)</span>, which is complex. Note that in the fidelity above (and also in the corresponding objective function <span class="arithmatex">\(J_{trace}\)</span>, the absolute value is taken <em>outside</em> of the sum, hence relative phases are taken into account.</p>
<p>Further note that this fidelity is averaged over the chosen initial conditions, so the user should be careful how to interpret this number. E.g. if one optimizes for a logical gate while choosing the three initial condition as in Section <a href="#sec:initcond">Initial conditions</a>, the fidelity that is reported during optimization will be averaged over those three initial states, which is not sufficient to estimate the actual average fidelity over the entire space of potential initial states. It is advised to recompute the average fidelity <strong>after</strong> optimization has finished by propagating all basis states <span class="arithmatex">\(B_{kj}\)</span> to final time <span class="arithmatex">\(T\)</span> using the optimized control parameter, or by propagating only <span class="arithmatex">\(N+1\)</span> initial states to get an estimate thereof.</p>
<h2 id="sec:targets">Optimization targets</h2>
<h3 id="gate-optimization">Gate optimization</h3>
<p>Quandary can be used to design control pulses that realize logical gate operations. Let <span class="arithmatex">\(V\in \C^{N\times N}\)</span> be the unitary matrix (gate), optimized control pulses drive any initial state <span class="arithmatex">\(\rho(0)\)</span> to the unitary transformation <span class="arithmatex">\(\rho^{target} = V\rho(0)V^{\dagger}\)</span> (Lindblad), or, in the Schroedinger case, drive any <span class="arithmatex">\(\psi(0)\)</span> to <span class="arithmatex">\(\psi(T) =  V\psi(0)\)</span>.
Some default target gates that are readily available, or can be specified from file or through the Python interface. (File format: column-wise vectorization, first all real parts then all imaginary parts.)</p>
<p>Since <em>any</em> initial quantum state should be transformed by the control pulses, the corresponding initial conditions must span a basis with <span class="arithmatex">\(n_{init} = N\)</span> for Schroedinger solver, and <span class="arithmatex">\(n_{init}=N^2\)</span> for Lindblad solver, see Section <a href="#sec:initcond">Initial conditions</a>. </p>
<p>Target gates will by default be rotated into the computational frame (Section <a href="#sec:model">Model equation</a>). Alternatively, the user can specify the rotation of the target gate through the configuration option <code>gate_rot_freq</code>.</p>
<p>If guard levels are used (<span class="arithmatex">\(n_k &gt; n_k^e\)</span>, compare Section <a href="#sec:essential">Essential and guard levels</a>), the gate should be defined in the essential-level dimensions only. Internally, the gate is projected upwards to the full dimensions by inserting identity blocks for rows/columns that correspond to a non-essential levels of the subsystems. Hence, a realization of the gate <span class="arithmatex">\(\tilde{V}\)</span> will not alter the occupation of higher (non-essential) energy level compared to their initial occupation at <span class="arithmatex">\(t=0\)</span>.</p>
<h3 id="sec:stateprep">State preparation</h3>
<p>Quandary can be used to optimize for pulses that drive (one or multiple) initial states to a fixed target state <span class="arithmatex">\(\rho^{target}\)</span>. Depending on the choice of the <a href="#sec:initcond">Initial conditions</a>, this enables pulses for either direct <strong>state-to-state transfer</strong> (by choosing one specific initial condition, <span class="arithmatex">\(n_{init}=1\)</span>), and one specific target state), or <strong>unconditional state preparation</strong> such as qubit reset (by spanning a basis of initial conditions, <span class="arithmatex">\(n_{init}=N\)</span> or $N^2, and one specific target state). Driving a basis of initial state to a common target will require to couple to a dissipative bath, which should be accounted for in the model setup. For unconditional <em>pure</em>-state preparation, it is shown in <sup id="fnref2:guenther2021quantum"><a class="footnote-ref" href="#fn:guenther2021quantum">2</a></sup> that if one chooses the objective function <span class="arithmatex">\(J_{measure}\)</span> with corresponding measurement operator <span class="arithmatex">\(N_m\)</span> (see eq. <span class="arithmatex">\(\eqref{eq:Jmeasure}\)</span>), one can reduce the number of initial conditions to only <em>one</em> being an ensemble of all basis states, and hence <span class="arithmatex">\(n_{init}=1\)</span> independent of <span class="arithmatex">\(N\)</span>. Compare <sup id="fnref3:guenther2021quantum"><a class="footnote-ref" href="#fn:guenther2021quantum">2</a></sup> for details.</p>
<p>If the target state is <em>pure</em>, internal computations are simplified and it is recommended to pass the specific identifier <code>pure, i0, i1, i2, ...</code> to the Quandary configuration for the optimization target, denoting a pure target state of the form <span class="arithmatex">\(\psi = |i_0i_1i_2...\rangle\)</span>, or <span class="arithmatex">\(\rho = \psi\psi^\dagger\)</span></p>
<h2 id="sec:initcond">Initial conditions</h2>
<p>The initial states <span class="arithmatex">\(\rho_i(0)\)</span> which are accounted for in the objective function eq. <span class="arithmatex">\(\eqref{eq:minproblem}\)</span> can be specified with the configuration option <code>initialcondition</code>. </p>
<ul>
<li>
<p><strong>Basis states for gate optimization</strong>: <span class="arithmatex">\(n_{init}=N\)</span> (Schroedinger case), or <span class="arithmatex">\(n_{init}=N^2\)</span> Lindblad case. For the Schroedinger case, the basis states are the unit vectors <span class="arithmatex">\(\psi_i(0)=\boldsymbol{e}_i \in \R^N, i=0,\dots N-1\)</span>. For the Lindblad's case, the <span class="arithmatex">\(N^2\)</span> basis density matrices defined in <sup id="fnref6:guenther2021quantum"><a class="footnote-ref" href="#fn:guenther2021quantum">2</a></sup> are used as initial states. 
In order to uniquely identify the different initial conditions in the Quandary code and in the output files, a
unique index <span class="arithmatex">\(i \in \{0,\dots, N^2-1\}\)</span> is assigned to each basis state with <span class="arithmatex">\(B^i := B^{k(i), j(i)}\)</span> with <span class="arithmatex">\(k(i) := i \,\mbox{mod}\, N\)</span> and <span class="arithmatex">\(j(i) := \left\lfloor \frac{i}{N} \right\rfloor\)</span>
(column-wise vectorization of the matrix of basis matrices).
<br>
For composite systems of multiple subsystems, the user can specify a consecutive list of integer ID's to determine in which of the subsystems the basis states should be spanned. Other subsystems will then be initialized in the ground state only.
<br>
<em>Note:</em> The basis states are spanned in the <em>essential dimensions</em> of the system, if applicable.</p>
</li>
<li>
<p><strong>Only diagonal density basis matrices</strong>: <span class="arithmatex">\(n_{init}=N\)</span>. For the Lindblad solver, one can choose to propagate only the <em>diagonal</em> basis matrices <span class="arithmatex">\(\boldsymbol{e}_k\boldsymbol{e}_k^\dagger\)</span>. For the Schroedinger solver, this option is equivalent to all basis states.
<br>
<em>Note:</em> the diagonal states are spanned in the <em>essential dimensions</em> of the system, if applicable.</p>
</li>
<li>
<p><strong>Three initial states for gate optimization</strong>: <span class="arithmatex">\(n_{init}=3\)</span>. <em>Only valid for the Lindblad solver.</em>
When considering gate optimization with Lindblad's solver, it is shown in <sup id="fnref2:goerz2014optimal"><a class="footnote-ref" href="#fn:goerz2014optimal">4</a></sup> that it is enough to consider only three specific initial states during optimization (<span class="arithmatex">\(n_{init}=3\)</span>), independent of the Hilbert space dimension. They are readily implemented in Quandary. Note that it is important to choose the weights <span class="arithmatex">\(\beta_i, i=1,2,3\)</span> in the objective function appropriately to achieve fast convergence.
<br>
Note: The three initial states are spanned in the <em>full</em> dimension of the system, including non-essential levels. The theory for gate optimization with three initial states had been developed for considering <em>only</em> essential levels (the gate is defined in the same dimension as the system state evolution), and at this point we are not certain if the theory generalizes to the case when non-essential levels are present. It is advised to optimize on the full basis if non-essential levels are present (or work on the theory, and let us know what you find.). The same holds for <span class="arithmatex">\(N+1\)</span> initial states below.</p>
</li>
<li>
<p><strong><span class="arithmatex">\(N+1\)</span> initial states for gate optimization</strong>: <span class="arithmatex">\(n_{init}=N+1\)</span>. <em>Only valid for the density matrix version, solving Lindblad's master equation.</em>
The three initial states from above do not suffice to estimate the fidelity of the realized gate (compare <sup id="fnref:goerz2014optimal"><a class="footnote-ref" href="#fn:goerz2014optimal">4</a></sup>). Instead, it is suggested in that same paper to choose <span class="arithmatex">\(N+1\)</span> initial states to compute the fidelity. Those <span class="arithmatex">\(N+1\)</span> initial states consist of the <span class="arithmatex">\(N\)</span> diagonal states <span class="arithmatex">\(B^{kk}\)</span> in the Hilbert space of dimension <span class="arithmatex">\(N\)</span>, as well as the totally rotated state <span class="arithmatex">\(\rho(0)_2\)</span> from above. 
<br>
Note: The <span class="arithmatex">\(N+1\)</span> initial states are spanned in the <em>full</em> dimension of the system, including non-essential levels, see above for 3-state initialization.</p>
</li>
<li>
<p><strong>Pure initial state for state-to-state transfer</strong>: <span class="arithmatex">\(n_{init} = 1\)</span>. The user can choose a pure initial state of the form <span class="arithmatex">\(\psi(0) = |i_0, i_1, i_2, ...\rangle\)</span>, or <span class="arithmatex">\(\rho(0) = \psi(0)\psi(0)^\dagger\)</span>, through the configuration option <code>pure, i0, i1, i2, ...</code></p>
</li>
<li>
<p><strong>Arbitrary initial state for state-to-state transformation</strong>: <span class="arithmatex">\(n_{init}=1\)</span>. An arbitrary (non-pure) initial state can be passed to Quandary directly through the Python interface, or can be read from a file in the C++ code. File format: column-wise vectorized density matrix or the state vector, first all real parts, then all imaginary parts. </p>
</li>
<li>
<p><strong>Ensemble state for unconditional pure-state preparation</strong>: <span class="arithmatex">\(n_{init}=1\)</span>. <em>Only valid for Lindblad's solver.</em> When choosing the objective function <span class="arithmatex">\(J_{measure}\)</span> <span class="arithmatex">\(\eqref{eq:Jmeasure}\)</span>, one can use the ensemble state <span class="arithmatex">\(\rho_s(0) = \frac{1}{N^2}\sum_{i,j=0}^{N-1} B^{kj}\)</span> as the only initial condition for optimizing for pulses that realize unconditional pure-state preparation, compare <sup id="fnref5:guenther2021quantum"><a class="footnote-ref" href="#fn:guenther2021quantum">2</a></sup>). To specify the ensemble state in Quandary (C++), one can provide a list of consecutive integer ID's that determine in which of the subsystems the ensemble state should be spanned. Other subsystems will be initialized in the ground state.
<br>
<em>Note</em>: The ensemble state will be spanned in the <em>essential</em> levels of the (sub)system, if applicable, and will then be lifted up to the full dimension by inserting zero rows and columns.</p>
</li>
</ul>
<h2 id="sec:penalty">Regularization, penalty terms, and leakage prevention</h2>
<p>In order to regularize the optimization problem (stabilize optimization convergence), it is advised to add a Tikhonov regularization term to the objective function, by choosing a small <span class="arithmatex">\(\gamma_1 &gt; 0\)</span></p>
<pre class="arithmatex">\[\begin{align}
  \mbox{Tikhonov} = \frac{\gamma_1}{2} \| \bfa \|^2_2
\end{align}\]</pre>
<p>In addition, the following penalty terms can be added to the objective function, if desired:</p>
<pre class="arithmatex">\[\begin{align*}
  Penalty &amp;= \frac{\gamma_2}{T} \int_0^T P\left(\{\rho_i(t)\}\right) \, \mathrm{d} t   \hspace{3cm} \rightarrow \text{Leakage prevention}\\
         &amp;+  \frac{\gamma_3}{T} \int_0^T \, \| \partial_{tt} \mbox{Pop}(\rho_i(t)) \|^2 \mathrm{d}t \hspace{2cm} \rightarrow \text{State variation penalty} \\
        &amp;+\frac{\gamma_4}{T} \int_0^T \, \sum_k |d^k(\alpha^k,t)|^2\, dt  \hspace{2cm}\rightarrow  \text{Control energy penalty}\\
        &amp;+ \frac{\gamma_5}{2} Var(\vec{\alpha}) \hspace{4cm}\rightarrow  \text{Control variation penalty}
\end{align*}\]</pre>
<ul>
<li>
<p><strong>Leakage prevention:</strong> Choose a small <span class="arithmatex">\(\gamma_2 &gt; 0\)</span> to penalize (suppress) leakage into non-essential energy levels (if <span class="arithmatex">\(n_k^e &lt; n_k\)</span> for at least <span class="arithmatex">\(k\)</span>, compare Sec. <a href="#sec:essential">Essential and non-essential energy levels</a>). This term penalizes the occupation of all <em>guard levels</em> with <span class="arithmatex">\(P(\rho(t)) = \sum_{r} \| \rho(t)_{rr} \|^2_2\)</span>, where <span class="arithmatex">\(r\)</span> iterates over all indices that correspond to a guard level (i.e., the final (highest) non-essential energy level) of at least one of the subsystems, and <span class="arithmatex">\(\rho(t)_{rr}\)</span> denotes their corresponding population.</p>
</li>
<li>
<p><strong>State variation penalty</strong>: Choose a small <span class="arithmatex">\(\gamma_3 &gt; 0\)</span> to encourage state evolutions whose populations vary slowly in time by penalizing the second derivative of the populations of the state.</p>
</li>
<li>
<p><strong>Control energy penalty</strong>: Choose a small <span class="arithmatex">\(\gamma_4 &gt; 0\)</span> to encourage small control pulse amplitudes by penalizing the control pulse energy. This term can be useful if hardware bounds are given for the control pulse amplitudes: Rather than specifying control bounds for the optimization directly, which can lead to convergence deterioration, one can utilize this penalty term to favor control pulses with smaller amplitudes. Compare also <sup id="fnref:gunther2023practical"><a class="footnote-ref" href="#fn:gunther2023practical">5</a></sup> for its usage to determine minimal gate durations.</p>
</li>
<li>
<p><strong>Control variation penalty</strong>: Choose a small <span class="arithmatex">\(\gamma_5&gt;0\)</span> to penalize variations in control strength between consecutive B-spline coefficients. It is currently only implemented for piecewise zeroth order spline functions, see Section <a href="#sec:bspline-0">Zeroth order B-spline basis functions</a>, where it is useful to prevent noisy control pulses. Referring to the control function representation in <span class="arithmatex">\(\eqref{eq:spline-ctrl}\)</span>, this penalty function takes the form:
<span class="arithmatex">\(Var(\vec{\alpha}) = \sum_{k=1}^Q Var_k(\vec{\alpha})\)</span> with <span class="arithmatex">\(Var_k(\vec{\alpha}) = \sum_{f,s}|\alpha_{s,f}^k - \alpha_{s-1,f}^k|^2\)</span>.</p>
</li>
</ul>
<p>Note: All regularization and penalty coefficients <span class="arithmatex">\(\gamma_i\)</span> should be chosen small enough so that they do not dominate the final-time objective function <span class="arithmatex">\(J\)</span>. This might require some fine-tuning. It is recommended to always add <span class="arithmatex">\(\gamma_1&gt;0\)</span>, e.g. <span class="arithmatex">\(\gamma_1 = 10^{-4}\)</span>, and add other penalties only if needed.</p>
<!--
Achieving a target at EARLIER time-steps:
\begin{align}\label{eq:penaltyterm}
  P(\rho(t))  =  w(t) J\left(\rho(t)\right) \quad \text{where} \quad w(t) =
  \frac{1}{a} e^{ -\left(\frac{t-T}{a} \right)^2},
\end{align}
for a penalty parameter $0 \leq a \leq 1$. Note, that as $a\to 0$, the weighting function $w(t)$ converges to the Dirac delta distribution with peak at final time $T$, hence reducing $a$ leads to more emphasis on the final time $T$ while larger $a$ penalize non-zero energy states at earlier times $t\leq T$.
-->

<h2 id="optimization-algorithm">Optimization algorithm</h2>
<p>Quandary utilized Petsc's Toolkit for Advanced Optimization (TAO) package to solve the optimal control problem. In the current setup, Quasi-Newton updates are applied to the control parameters using L-BFGS Hessian approximations. A projected line-search is used to incorporate box constraints for control pulse amplitude bounds <span class="arithmatex">\(|p^k(t)| \leq c^k_{max}\)</span>, <span class="arithmatex">\(|q^k(t)| \leq c^k_{max}\)</span> via</p>
<pre class="arithmatex">\[\begin{align}
  | \alpha_{s,f}^{k(1)}| \leq \frac{c^k_{max}}{\sqrt{2}N_f^k} \quad \text{and} \quad |
  \alpha_{s,f}^{k(2)} | \leq \frac{c^k_{max}}{\sqrt{2}N_f^k}.
\end{align}\]</pre>
<h1 id="implementation">Implementation</h1>
<h2 id="real-valued-and-vectorized-formulation">Real-valued and vectorized formulation</h2>
<p>Quandary solves the quantum dynamical system in real-valued variables with <span class="arithmatex">\(q(t) = u(t) + iv(t)\)</span>, evolving the real-valued
states <span class="arithmatex">\(u(t), v(t)\in \R^{M}\)</span> for <span class="arithmatex">\(M=N\)</span> (if Schroedinger's eq.) or <span class="arithmatex">\(M=N^2\)</span> (if Lindblad's eq., see below). Particularly, considering Schroedinger's equation first, the real-valued dynamical system is given by </p>
<pre class="arithmatex">\[\begin{align}
  \dot{q}(t) = -iH(t) q(t) \quad \Leftrightarrow \quad &amp;\begin{bmatrix} \dot{u}(t) \\ \dot{v}(t) \end{bmatrix} =
\begin{bmatrix} A(t) &amp; -B(t) \\ B(t) &amp; A(t) \end{bmatrix}
\begin{pmatrix} u(t) \\ v(t) \end{pmatrix}  \\
\notag\\
\text{where} \quad A(t) &amp;= Re(-iH(t)) = Im(H)\notag \\
     B(t) &amp;= Im(-iH(t)) = -Re(H(t))\notag
\label{realvaluedODE}
\end{align}\]</pre>
<p>When solving Lindblad's master equation <span class="arithmatex">\(\eqref{mastereq}\)</span>, Quandary uses the column-wise vectorization relations</p>
<pre class="arithmatex">\[\begin{align}
  \text{vec}(AB) &amp;= (I_N\otimes A)\text{vec}(B) = (B^T\otimes I_N)\text{vec}(A)
  \\
  \text{vec}(ABC) &amp;= (C^T\otimes A)\text{vec}(B)
\end{align}\]</pre>
<p>to derive the vectorized master equation for <span class="arithmatex">\(q(t) := \text{vec}(\rho(t)) \in \C^{N^2}\)</span>, and its real-valued formulation as</p>
<pre class="arithmatex">\[\begin{align}\label{mastereq_vectorized}
  &amp;\dot{q}(t) = \left(I_N\otimes \left(-i H(t)\right) - \left(-iH(t)\right)^T \otimes I_N  + \vec L \right) q(t) \quad  \text{for} \quad
  \vec L := \sum_{k=0}^{Q-1}\sum_{l=1}^2 \gamma_{lk}
  \left( \Ell_{lk}\otimes \Ell_{lk} - \frac 1 2 \left( I_N\otimes
  \Ell^T_{lk}\Ell_{lk} + \Ell^T_{lk}\Ell_{lk} \otimes I_N \right) \right) \\
  &amp;\Leftrightarrow \quad \begin{bmatrix} \dot{u}(t) \\ \dot{v}(t) \end{bmatrix} =
\begin{bmatrix} A(t) &amp; -B(t) \\ B(t) &amp; A(t) \end{bmatrix}
\begin{pmatrix} u(t) \\ v(t) \end{pmatrix}  \quad \text{where}\quad A(t) = I_N\otimes Re(-i H(t)) - Re(-iH(t))^T \otimes I_N + \vec L \notag \\
&amp; \qquad \qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\quad  B(t) = I_N\otimes Im(-i H(t)) - Im(-iH(t))^T \otimes I_N)  \notag 
\end{align}\]</pre>
<p>The real and imaginary parts of <span class="arithmatex">\(q(t)\)</span> are stored in blocked manner: For
  <span class="arithmatex">\(q = u+iv\)</span> with <span class="arithmatex">\(u,v\in\R^{M}\)</span>, a vector of size <span class="arithmatex">\(2M\)</span> as $q=\begin{bmatrix} u\v \end{bmatrix}.</p>
<h2 id="time-stepping">Time-stepping</h2>
<p>To solve the resulting real-valued differential equation </p>
<pre class="arithmatex">\[\begin{align*}
\dot q(t) = M(t) q(t) \forall t\in (0,T), \quad \text{with}\quad M(t) =\begin{bmatrix} A(t) &amp; -B(t) \\ B(t) &amp; A(t) \end{bmatrix} 
\end{align*}\]</pre>
<p>Quandary applies a time-stepping integration scheme on a uniform time discretization grid <span class="arithmatex">\(0=t_0 &lt; \dots t_{N} = T\)</span>, with
<span class="arithmatex">\(t_n = n \delta t\)</span> and <span class="arithmatex">\(\delta t = \frac{T}{N}\)</span> to approximate the
solution at each discrete time-step <span class="arithmatex">\(q^{n} \approx q(t_n)\)</span>. The default and recommended time-stepping scheme is the Implicit Midpoint Rule <code>IMR</code>. The implicit midpoint rule is a second-order accurate, symplectic time-stepping algorithm with Runge-Kutta scheme tableau
<span class="arithmatex">\(\begin{array}{c|c}
1/2 &amp; 1/2 \\
\hline
&amp; 1
\end{array}\)</span>
Given a state <span class="arithmatex">\(q^n\)</span> at time <span class="arithmatex">\(t_n\)</span>, the update formula to compute <span class="arithmatex">\(q^{n+1}\)</span>
is given by</p>
<pre class="arithmatex">\[\begin{align}
  q^{n+1} = q^n + \delta t k_1 \quad \text{where} \, k_1 \, \text{solves}
  \quad \left( I-\frac{\delta t}{2} M^{n+1/2} \right) k_1 = M^{n+1/2}  q^n
\end{align}\]</pre>
<p>where <span class="arithmatex">\(M^{n+1/2} := M(t_n + \frac{\delta t}{2})\)</span>. In each time-step,
a linear equation is solved using GMRES to compute the stage variable <span class="arithmatex">\(k_1\)</span>, which is then used it
to update <span class="arithmatex">\(q^{n+1}\)</span>.</p>
<p>In addition to the IMR, two higher-order time-stepping schemes are available in Quandary, particularly a 4-th order and a 8-th order scheme which both are compsitional versions of the IMR. Those methods perform multiple composed IMR steps in each time-step interval to achieve higher order accuracy. Particularly, the 4-th order scheme (<code>IMR4</code>) performs 3 sub-steps per time interval, and the 8-th order (<code>IMR8</code>) performs 15 sub-steps per time time interval. Compared to the standard IMR, the higher-order methods allow for much larger time-steps to be taken to reach a certain accuracy tolerance, however, more work is done per time-step, creating a tradeoff at which the compositional methods can outperform the standard IMR scheme.</p>
<h3 id="choice-of-the-time-step-size">Choice of the time-step size</h3>
<!-- The python interface to Quandary automatically computes a time-step size based on the fastest period of the system Hamiltonian. For the C++ code, it needs to be set by the user.  -->

<p>In order to estimate a time-step size <span class="arithmatex">\(\delta t\)</span> that yields stable and accurate timestepping, Quandary's Python interface performs an eigenvalue decomposition of the system Hamiltonian <span class="arithmatex">\(H_d\)</span> to determine the fastest period of intrinsic dynamics. The user can adjust the desired number of timesteps (<span class="arithmatex">\(P_{min}\)</span>) that are used to discretize per fastest period, and the time-step size is then computed from </p>
<pre class="arithmatex">\[\begin{align} \label{eq:timestepsize}
  \delta t = \frac{\tau_{min}}{P_{min}} = \frac{2\pi}{P_{min} \lambda_{max}}
\end{align}\]</pre>
<p>where <span class="arithmatex">\(\lambda_{max}\)</span> is the largest eigenvalue of the Hamiltonian. For the 2nd order IMR scheme, we recommend at least <span class="arithmatex">\(P_{min}=80\)</span>. </p>
<p>In order to test time-stepping accuracy, a standard <span class="arithmatex">\(\Delta t\)</span>-test is recommended performed to ensure that the chosen time-step is small enough. For example, one can compute the <em>Richardson error estimator</em> of the current approximation error in <span class="arithmatex">\(J^{\Delta t}\)</span> compared to the true quantity <span class="arithmatex">\(J^*\)</span> with </p>
<pre class="arithmatex">\[\begin{align}
  J^* - J^{\Delta t} = \frac{J^{\Delta t} - J^{\Delta t m}}{1-m^p} + O(\Delta t^{p+1})
\end{align}\]</pre>
<p>where <span class="arithmatex">\(p\)</span> is the order of the time-stepping scheme (i.e. <span class="arithmatex">\(p=2\)</span> for the IMR and <span class="arithmatex">\(p=8\)</span> for the compositional IMR8), and <span class="arithmatex">\(J^{\Delta t}, J^{\Delta tm}\)</span> are approximations of the target quantity when using time-step sizes <span class="arithmatex">\(\Delta t\)</span> and <span class="arithmatex">\(\Delta t m\)</span>, for a factor <span class="arithmatex">\(m\)</span>.</p>
<h2 id="sparse-matrix-vs-matrix-free-solver">Sparse-matrix vs. matrix-free solver</h2>
<p>Solving the differential equation with a time-stepping scheme requires efficient application of the right-hand-side (RHS) system matrix <span class="arithmatex">\(M(t)\)</span> to a (vectorized) state <span class="arithmatex">\(q\)</span>. In Quandary, two versions to evaluate the matrix product <span class="arithmatex">\(M(t)q(t)\)</span> are available:</p>
<ol>
<li>
<p>The <em>sparse-matrix solver</em> uses PETSc's sparse matrix format (sparse AIJ) to set up (and store) all building blocks inside <span class="arithmatex">\(A(t)\)</span> and <span class="arithmatex">\(B(t)\)</span>, compare the appendix. Sparse matrix-vector products are then applied at each time-step to evaluate the products <span class="arithmatex">\(A(t)u(t) - B(t) v(t)\)</span> and <span class="arithmatex">\(B(t)u(t) + A(t)v(t)\)</span>. For developers, the appendix provides details on each term within <span class="arithmatex">\(A(t)\)</span> and <span class="arithmatex">\(B(t)\)</span> which can be matched to the implementation in the code (class <code>MasterEq</code>).</p>
</li>
<li>
<p>The <em>matrix-free solver</em> considers the quantum state to be a tensor of rank <span class="arithmatex">\(Q\)</span> (Schroedinger) or <span class="arithmatex">\(2Q\)</span> (Lindblad). Instead of storing the building block matrices inside <span class="arithmatex">\(M(t)\)</span>, the matrix-free solver applies tensor contractions to realize the action of <span class="arithmatex">\(A(t)\)</span> and <span class="arithmatex">\(B(t)\)</span> on the state vector. The matrix-free solver is much faster than the sparse-matrix solver (about 10x), no surprise. However the matrix-free solver is currently only implemented for systems of <strong>2, 3, 4, or 5</strong> oscillators.</p>
</li>
</ol>
<!-- **The matrix-free solver currently does not parallelize across the system dimension $N$**, hence the state vector is **not** distributed (i.e. no parallel Petsc!). The reason why we did not implement that yet is that $Q$ can often be large while each axis can be very short (e.g. modelling $Q=12$ qubits with $n_k=2$ energy levels per qubit), which yields a very high-dimensional tensor with very short axes. In that case, the standard (?) approach of parallelizing the tensor along its axes will likely lead to very poor scalability due to high communication overhead. We have not found a satisfying solution yet - if you have ideas, please reach out, we are happy to collaborate! -->

<h2 id="gradient-computation-via-discrete-adjoint-back-propagation">Gradient computation via discrete adjoint back-propagation</h2>
<p>Quandary computes the gradients of the objective function with respect to the design variables <span class="arithmatex">\(\boldsymbol{\alpha}\)</span> using the discrete adjoint method. The discrete adjoint approach yields exact and consistent gradients on the algorithmic level, at costs that are independent of the number of design variables.
To that end, the adjoint approach propagates local sensitivities backwards through the time-domain while concatenating contributions to the gradient using the chain-rule.</p>
<p>For the IMR timestepper, the discrete adjoint time-integration step for
adjoint variables denoted by <span class="arithmatex">\(\bar q^{n}\)</span> is given by</p>
<pre class="arithmatex">\[\begin{align}
  \bar q^{n} = \bar q^{n+1} + \delta t \left(M^{n+1/2}\right)^T \bar k_1
  \quad \text{where} \, \bar k_1 \, \text{solves} \quad \left(
  I-\frac{\delta t}{2} M^{n+1/2}\right)^T  \bar k_1 = \bar q^{n+1}
\end{align}\]</pre>
<p>The contribution to the gradient <span class="arithmatex">\(\nabla J\)</span> for each time-step is</p>
<pre class="arithmatex">\[\begin{align}\label{eq:gradient}
  \nabla J += \delta t \left( \frac{\partial M^{n+1/2}}{\partial z}
  \left(q^n + \frac{\delta t}{2} k_1\right) \right)^T\bar k_1
\end{align}\]</pre>
<p>Each evaluation of the gradient <span class="arithmatex">\(\nabla J\)</span> involves a forward solve of <span class="arithmatex">\(n_{init}\)</span> initial quantum states to evaluate the objective function at final time <span class="arithmatex">\(T\)</span>, as well as <span class="arithmatex">\(n_{init}\)</span> backward solves to compute the adjoint states and the contributions to the gradient. Note that the gradient computation <span class="arithmatex">\(\eqref{eq:gradient}\)</span> requires the states and adjoint states at each time-step. For the Schroedinger solver, the primal states are recomputed by integrating Schroedinger's equation backwards in time, alongside the adjoint computation. For the Lindblad solver, the states <span class="arithmatex">\(q^n\)</span> are stored during forward propagation, and taken from storage during adjoint back-propagation (since we can't recompute it in case of Lindblad solver, due to dissipation).</p>
<p>For developers, a Central Finite Difference (CFD) test can be enabled by setting the compiler directive <code>TEST_FD_GRAD = 1</code> at the beginning of the <code>src/main.cpp</code> file. Quandary will then iterate over all elements in <span class="arithmatex">\(\alpha\)</span> and report the <em>relative</em> error of the implemented gradient with respect to the "true" gradient computed from CFD:</p>
<pre class="arithmatex">\[\begin{align*}
    \left(\nabla J(\boldsymbol{\alpha}) \right)_i \approx \frac{J(\bfa + \epsilon\bs{e}_i) - J(\bfa - \epsilon\bs{e}_i)}{2\epsilon} 
\end{align*}\]</pre>
<p>for unit vectors <span class="arithmatex">\(\bs{e}_i\in \R^d\)</span>, and <span class="arithmatex">\(d\)</span> being the dimension of <span class="arithmatex">\(\bfa\)</span>.</p>
<h2 id="storage-of-the-control-parameters">Storage of the control parameters</h2>
<p>The control parameters <span class="arithmatex">\(\bs{\alpha}\)</span> are stored in the Quandary code in the following order: List oscillators first <span class="arithmatex">\((\vec{\alpha}^0, \dots, \vec{\alpha}^{Q-1})\)</span>, then for each <span class="arithmatex">\(\vec{\alpha}^k \in
\R^{2 N_s^k N_f^k}\)</span>, iterate over all carrierwaves <span class="arithmatex">\(\vec{\alpha}^k =
(\alpha^k_1,\dots, \alpha^k_{N_f})\)</span> with <span class="arithmatex">\(\alpha^k_f \in \R^{2 N_s^k}\)</span>, then each
<span class="arithmatex">\(\alpha^k_f\)</span> iterates over spline basis functions listing first all real then all imaginary
components: <span class="arithmatex">\(\alpha^k_f = \alpha^{k(1)}_{1,f}, \dots, \alpha^{k(1)}_{N_s^k,f}, \alpha^{k(2)}_{1,f}, \dots, \alpha^{k(2)}_{N_s^k,f}\)</span>. Hence there are a total of <span class="arithmatex">\(2\sum_k N_s^k N_f^k\)</span> real-valued optimization parameters, which are stored in the following order:</p>
<pre class="arithmatex">\[\begin{align}
  \boldsymbol{\alpha} &amp;:= \left( \vec{\alpha}^0, \dots, \vec{\alpha}^{Q-1} \right), \in
  \R^{2\sum_k N_s^k N_f^k} \quad \text{where}\\
  \vec{\alpha}^k = &amp;\left( \alpha_{1,1}^{k(1)},\dots, \alpha_{N_s^k,1}^{k(1)}, \dots, \alpha_{1,N_f^k}^{k(1)}, \dots, \alpha_{N_s^k,N_f^k}^{k(1)} \right.\\
                 &amp;  \left. \alpha_{1,1}^{k(2)},\dots, \alpha_{N_s^k,1}^{k(2)}, \dots, \alpha_{1,N_f^k}^{k(2)}, \dots, \alpha_{N_s^k,N_f^k}^{k(2)} \right)
\end{align}\]</pre>
<p>iterating over <span class="arithmatex">\(Q\)</span> subsystems first, then <span class="arithmatex">\(N_f^k\)</span> carrier wave frequencies, then <span class="arithmatex">\(N_s^k\)</span> splines, listing first all real parts then all imaginary parts. To access an element <span class="arithmatex">\(\alpha_{s,f}^{k(i)}\)</span>, <span class="arithmatex">\(i=0,1\)</span>, from storage <span class="arithmatex">\(\bfa\)</span>:</p>
<pre class="arithmatex">\[\begin{align}
  \alpha_{s,f}^{k(i)} = \bfa \left[ \left(\sum_{j=0}^{k-1} 2 N_s^j N_f^j\right) + f*2 N_s^k + s + i*N_s^k N_f^k \right],
\end{align}\]</pre>
<h1 id="parallelization">Parallelization</h1>
<p>Quandary offers two levels of parallelization using MPI.</p>
<ol>
<li>Parallelization over initial conditions: The <span class="arithmatex">\(n_{init}\)</span> initial conditions <span class="arithmatex">\(\rho_i(0)\)</span> can be distributed over <code>np_init</code> compute units. Since initial condition are propagated through the time-domain for solving Lindblad's or Schroedinger's equation independently from each other, speedup from distributed initial conditions is ideal.</li>
<li>Parallel linear algebra with Petsc (sparse-matrix solver only): For the sparse-matrix solver, Quandary utilizes Petsc's parallel sparse matrix and vector storage to distribute the state vector onto <code>np_petsc</code> compute units (spatial parallelization). To perform scaling results, make sure to disable code output (or reduce the output frequency to print only the last time-step), because writing the data files invokes additional MPI calls to gather data on the master node. Strong and weak scaling studies for parallel linear algebra are presented in <sup id="fnref4:guenther2021quantum"><a class="footnote-ref" href="#fn:guenther2021quantum">2</a></sup>.</li>
</ol>
<p>Since those two levels of parallelism are orthogonal, Quandary splits the global communicator (MPI_COMM_WORLD) into
two sub-communicator such that the total number of executing MPI
processes (<span class="arithmatex">\(np_{total}\)</span>) is split as</p>
<pre class="arithmatex">\[\begin{align*}
  np_{init} * np_{petsc} = np_{total}.
\end{align*}\]</pre>
<p>Since parallelization over different initial conditions is perfect, Quandary automatically sets <span class="arithmatex">\(np_{init} = n_{init}\)</span>, i.e. the total number of cores for distributing initial conditions is the total number of initial conditions that are considered in this run, as specified by the configuration option <code>intialcondition</code>. The number of cores for distributed linear algebra with Petsc is then computed from above.</p>
<p>It is currently required that the number of total cores for executing quandary is an integer divisor of multiplier of the number of initial conditions, such that each processor group owns the same number of initial conditions.</p>
<p>It is further required that the system dimension is an integer multiple of the number of cores used for distributed linear algebra from Petsc, i.e. it is required that <span class="arithmatex">\(\frac{M}{np_{petsc}} \in \mathbb{N}\)</span> where <span class="arithmatex">\(M=N^2\)</span> in the Lindblad solver case and <span class="arithmatex">\(M=N\)</span> in the Schroedinger case. This requirement is a little
  annoying, however the current implementation requires this due to the
  storage of the real and imaginary parts of the vectorized
  state.</p>
<h1 id="output-and-plotting-the-results">Output and plotting the results</h1>
<p>Quandary generates various output files for system evolution of the current (optimized) controls as well as the optimization progress. All data files will be dumped into a user-specified folder through the config option <code>datadir</code>.</p>
<h3 id="output-options-with-regard-to-state-evolution">Output options with regard to state evolution</h3>
<p>For each subsystem <span class="arithmatex">\(k\)</span>, the user can specify the desired state evolution output through the config option <code>output&lt;k&gt;</code>:</p>
<ul>
<li>
<p><code>expectedEnergy</code>: This option prints the time evolution of the expected energy level of subsystem <span class="arithmatex">\(k\)</span> into files with naming convention <code>expected&lt;k&gt;.iinit&lt;i&gt;.dat</code>, where <span class="arithmatex">\(i=1,\dots,n_{init}\)</span> denotes the unique identifier for each initial condition <span class="arithmatex">\(\rho_i(0)\)</span> that was propagated through (see Section <a href="#sec:initcond">Initial conditions</a>). This file contains two columns, the first row being the time values, the second one being the expectation value of the energy level of subsystem <span class="arithmatex">\(k\)</span> at that time point, computed from</p>
<pre class="arithmatex">\[\begin{align}
  \langle N^{(n_k)}\rangle = \mbox{Tr}\left(N^{(n_k)} \rho^k(t)\right)
\end{align}\]</pre>
<p>where <span class="arithmatex">\(N^{(n_k)} = \left(a^{(n_k)}\right)^\dagger \left(a^{(n_k)}\right)\)</span> denotes the number operator in subsystem <span class="arithmatex">\(k\)</span> and <span class="arithmatex">\(\rho^k\)</span> denotes the reduced density matrix or state for subsystem <span class="arithmatex">\(k\)</span>. 
- <code>expectedEnergyComposite</code> Prints the time evolution of the expected energy level of the entire (full-dimensional) system state into files (one for each initial condition, as above): <span class="arithmatex">\(mbox{Tr}\left(N \rho(t)\right)\)</span> for the number operator <span class="arithmatex">\(N\)</span> in the full dimensions.
- <code>population</code>: This option prints the time evolution of the state's occupation in each energy level into files named <code>population&lt;k&gt;.iinit&lt;i&gt;.dat</code>, for each initial condition <span class="arithmatex">\(i=1,\dots, n_{init}\)</span> and each subsystem <span class="arithmatex">\(k\)</span>. The files contain <span class="arithmatex">\(n_k+1\)</span> columns, the first one being the time values, the remaining ones correspond to the population of each level <span class="arithmatex">\(l=0,\dots,n_k-1\)</span> of the reduced density matrix or state vector at that time point. For Lindblad's solver, these are the diagonal elements of the reduced density matrix (<span class="arithmatex">\(\rho_{ll}^k(t), l=0,\dots n_k-1\)</span>), for Schroedinger's solver it's the absolute values of the reduced state vector elements <span class="arithmatex">\(|\psi^k_l(t)|^2, l=0,\dots n_k-1\)</span>. 
- <code>populationComposite</code>: Prints the time evolution of the state populations of the entire (full-dimensional) system into files (one for each initial condition, as above).
- <code>fullstate</code>: For smaller systems, one can choose to print out the full state <span class="arithmatex">\(\rho(t)\)</span> or <span class="arithmatex">\(\psi(t)\)</span> for each time point into the files <code>rho_Re.iinit&lt;m&gt;.dat</code> and <code>rho_Im.iinit&lt;m&gt;.dat</code>, for the real and imaginary parts. These files contain <span class="arithmatex">\(N^2+1\)</span> (Lindblad) or <span class="arithmatex">\(N+1\)</span> (Schroedinger) columns the first one being the time point value and the remaining ones contain the vectorized density matrix or the state vector for that time point. Note that these file become very big very quickly -- use with care!</p>
</li>
</ul>
<p>The user can change the frequency of output in time (printing only every <span class="arithmatex">\(j\)</span>-th time point) through the option <code>output_frequency</code>. This is particularly important when doing performance tests, as computing the reduced states for output requires extra computation and communication that might skew performance tests.</p>
<h3 id="output-with-regard-to-simulation-and-optimization">Output with regard to simulation and optimization</h3>
<ul>
<li><code>config_log.dat</code> contains all configuration options that had been used for the current run of the C++ code.</li>
<li><code>params.dat</code> contains the control parameters <span class="arithmatex">\(\bfa\)</span> that had been used to determine the current control pulses. This file contains one column containing all parameters, ordered as stored, see Section <a href="#sec:controlpulses">Control pulses</a>.</li>
<li><code>control&lt;k&gt;.dat</code> contain the resulting control pulses applied to subsystem <span class="arithmatex">\(k\)</span> over time. It contains four columns, the first one being the time, second and third being <span class="arithmatex">\(p^k(t)\)</span> and <span class="arithmatex">\(q^k(t)\)</span> (rotating frame controls), and the last one is the corresponding lab-frame pulse <span class="arithmatex">\(f^k(t)\)</span>. Note that the units of the control pulses are in frequency domain (divided by <span class="arithmatex">\(2\pi)\)</span>. The unit matches the unit specified with the system parameters such as the qubit ground frequencies <span class="arithmatex">\(\omega_k\)</span>.</li>
<li><code>optim_history.dat</code> contains information about the optimization progress in terms of the overall objective function and contribution from each term (cost at final time <span class="arithmatex">\(T\)</span> and contribution from the tikhonov regularization and the penalty term), as well the norm of the gradient and the fidelity, for each iteration of the optimization. If only a forward simulation is performed, this file still prints out the objective function and fidelity for the forward simulation.
Quandary always prints the current parameters and control pulses at the beginning of a simulation or optimization, and in addition at every <span class="arithmatex">\(l\)</span>-th optimization iteration determined from the <code>optim_monitor_frequency</code> configuration option.</li>
</ul>
<h3 id="plotting">Plotting</h3>
<p>The format of all output files are very well suited for plotting with <a href="http://www.gnuplot.info">Gnuplot</a>, which is a command-line based plotting program that can output directly to screen, or into many other formats such as png, eps, or even tex. As an example, from within a Gnuplot session, you can plot e.g. the expected energy level of subsystem <span class="arithmatex">\(k=0\)</span> for initial condition <span class="arithmatex">\(m=0\)</span> by the simple command</p>
<pre><code class="language-console">gnuplot&gt; plot 'expected0.iinit0000.dat' using 1:2 with lines title 'expected energy subsystem 0'
</code></pre>
<p>which plots the first against the second column of the file 'expected0.iinit0000.dat' to screen, connecting each point with a line. Additional lines (and files) can be added to the same plot by extending the above command with another file separated by comma. There are many example scripts for plotting with gnuplot online, and as a starting point I recommend looking into some scripts in the 'quandary/util/' folder.</p>
<h1 id="testing">Testing</h1>
<p>Quandary has a set of regression tests. Please take a look at the <code>tests/regression/README.md</code> document for instructions on how to run the regression tests.</p>
<h1 id="acknowledgments">Acknowledgments</h1>
<p>This work was performed under the auspices of the U.S. Department of Energy by Lawrence
Livermore National Laboratory under Contract DE-AC52-07NA27344. LLNL-SM-818073.</p>
<!--
This document was prepared as an account of work sponsored by an agency of the United States
government. Neither the United States government nor Lawrence Livermore National Security, LLC,
nor any of their employees makes any warranty, expressed or implied, or assumes any legal
liability or responsibility for the accuracy, completeness, or usefulness of any information,
apparatus, product, or process disclosed, or represents that its use would not infringe
privately owned rights. Reference herein to any specific commercial product, process, or service
by trade name, trademark, manufacturer, or otherwise does not necessarily constitute or imply
its endorsement, recommendation, or favoring by the United States government or Lawrence
Livermore National Security, LLC. The views and opinions of authors expressed herein do not
necessarily state or reflect those of the United States government or Lawrence Livermore
National Security, LLC, and shall not be used for advertising or product endorsement purposes.
-->

<h1 id="appendix-details-for-the-real-valued-system-matrices-standard-model">Appendix: Details for the real-valued system matrices (standard model)</h1>
<p>The RHS system matrices <span class="arithmatex">\(A(t) = Re(-iH(t))=Im(H(t))\)</span> and <span class="arithmatex">\(B(t) = Im(-iH(t)) = -Re(H(t))\)</span> for the standard Hamiltonian model are assembled as follows. </p>
<pre class="arithmatex">\[\begin{align}
A(t) &amp;= A_d + \sum_k  q^k(\vec{\alpha}^k,t) A_c^k + \sum_{l&gt;k} J_{kl} \sin(\eta_{kl}t)  A_d^{kl} \\
B(t) &amp;=  B_d + \sum_k p^k(\vec{\alpha}^k,t) B_c^k + \sum_{kl} J_{kl} \cos(\eta_{kl}t)B_d^{kl}\\
\end{align}\]</pre>
<p><strong>Schroedinger solver</strong>:</p>
<pre class="arithmatex">\[\begin{align}
  A_d &amp;:= 0\\
  A_c^k &amp;:=  a_k - a_k^\dagger  \\
  A_d^{kl} &amp;:=  a_k^\dagger a_l + a_k a_l^\dagger \\
\notag\\
  B_d &amp;:= \sum_k -(\omega_k - \omega_k^{\text{rot}}) a_k^\dagger a_k  + \frac{\xi_k}{2}\left( a_k^\dagger a_k^\dagger a_k a_k \right)  + \sum_{l&gt;k}  \xi_{kl}\left(a_k^\dagger a_k a_l^\dagger a_l  \right)\\
    B_c^k &amp;:=  -(a_k + a_k^\dagger) \\
    B_d^{kl} &amp;:=  - \left(a_k^\dagger a_l + a_k a_l^\dagger\right)  
\end{align}\]</pre>
<p><strong>Lindblad solver</strong></p>
<pre class="arithmatex">\[\begin{align}
  A_d &amp;:= \vec L\\
  A_c^k &amp;:=  I_N \otimes \left(a_k - a_k^\dagger\right) - \left(a_k - a_k^\dagger\right)^T\otimes I_N \\
  A_d^{kl} &amp;:=  I_N\otimes \left(a_k^\dagger a_l - a_k a_l^\dagger\right) - \left(a_k^\dagger a_l - a_k a_l^\dagger\right)^T\otimes I_N \\
\notag\\
  B_d &amp;:= \sum_k -(\omega_k - \omega_k^{\text{rot}}) \left(I_N \otimes a_k^\dagger a_k - (a_k^\dagger a_k)^T \otimes I_N \right) + \frac{\xi_k}{2}\left( I_N \otimes a_k^\dagger a_k^\dagger a_k a_k - (a_k^\dagger a_k^\dagger a_k a_k )^T\otimes I_N\right)  \\
    &amp;\quad + \sum_{l&gt;k}  \xi_{kl} \left(I_N \otimes a_k^\dagger a_k a_l^\dagger a_l - (a_k^\dagger a_k a_l^\dagger a_l)^T \otimes I_N \right)\\
    B_c^k &amp;:=  -\left( I_N \otimes \left(a_k + a_k^\dagger\right) + \left(a_k + a_k^\dagger\right)^T\otimes I_N \right)\\
    B_d^{kl} &amp;:=  - \left(I_N\otimes \left(a_k^\dagger a_l + a_k a_l^\dagger\right) + \left(a_k^\dagger a_l + a_k a_l^\dagger\right)^T\otimes I_N \right)\\
\end{align}\]</pre>
<p>The sparse-matrix solver initializes and stores the building blocks 
<span class="arithmatex">\(A_d, A_d^{kl}, A_c^k, B_d, B_d^{kl}, B_c^k\)</span> using Petsc's sparse-matrix MPIAIJ format. The matrix-free solver (2-5 subsystems) applies the actions of those building blocks to state vectors.</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:guenther2021quandary">
<p>Stefanie Günther, N. Anders Petersson, and Jonathan L. DuBois. Quandary: an open-source c++ package for high-performance optimal control of open quantum systems. https://arxiv.org/abs/2110.10310, 2021. <a href="https://arxiv.org/abs/2110.10310">arXiv:2110.10310</a>.&#160;<a class="footnote-backref" href="#fnref:guenther2021quandary" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:guenther2021quantum">
<p>Stefanie Günther, N. Anders Petersson, and Jonathan L. DuBois. Quantum optimal control for pure-state preparation using one initial state. <em>AVS Quantum Science</em>, 3:043801, 2021. <a href="https://arxiv.org/abs/2106.09148">arXiv:2106.09148</a>.&#160;<a class="footnote-backref" href="#fnref:guenther2021quantum" title="Jump back to footnote 2 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:guenther2021quantum" title="Jump back to footnote 2 in the text">&#8617;</a><a class="footnote-backref" href="#fnref3:guenther2021quantum" title="Jump back to footnote 2 in the text">&#8617;</a><a class="footnote-backref" href="#fnref4:guenther2021quantum" title="Jump back to footnote 2 in the text">&#8617;</a><a class="footnote-backref" href="#fnref5:guenther2021quantum" title="Jump back to footnote 2 in the text">&#8617;</a><a class="footnote-backref" href="#fnref6:guenther2021quantum" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
<li id="fn:petersson2021optimal">
<p>N. Anders Petersson and Fortino Garcia. Optimal control of closed quantum systems via B-splines with carrier waves. <em>SIAM Journal on Scientific Computing</em>, 44(6):A3592&ndash;A3616, 2022. <a href="https://doi.org/10.1137/21M1429618">doi:10.1137/21M1429618</a>.&#160;<a class="footnote-backref" href="#fnref:petersson2021optimal" title="Jump back to footnote 3 in the text">&#8617;</a></p>
</li>
<li id="fn:goerz2014optimal">
<p>Michael H. Goerz, Daniel M. Reich, and Christiane P. Koch. Optimal control theory for a unitary operation under dissipative evolution. <em>New Journal of Physics</em>, 16(5):055012, 2014.&#160;<a class="footnote-backref" href="#fnref:goerz2014optimal" title="Jump back to footnote 4 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:goerz2014optimal" title="Jump back to footnote 4 in the text">&#8617;</a></p>
</li>
<li id="fn:gunther2023practical">
<p>Stefanie Günther and N. Anders Petersson. A practical approach to determine minimal quantum gate durations using amplitude-bounded quantum controls. <em>AVS Quantum Science</em>, 2023.&#160;<a class="footnote-backref" href="#fnref:gunther2023practical" title="Jump back to footnote 5 in the text">&#8617;</a></p>
</li>
</ol>
</div></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script src="../js/bootstrap.bundle.min.js"></script>
        <script>
            var base_url = "..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../js/base.js"></script>
        <script src="../javascripts/mathjax.js"></script>
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        <script src="../search/main.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
