#include <string>
#include "config.hpp"
#include <sstream>
#include <cstring>
#include <iostream>
#include <fstream>
#include "util.hpp"
#include "defs.hpp"
#include <assert.h>
#include <petscts.h>
#include <vector>
#pragma once

/* Abstract base data class */
class Data{
  protected:
    std::vector<int> nlevels; /* Dimensions of each subsytem */
    LindbladType lindbladtype; // Schroedinger or Lindblad solver
    int dim;              // Dimension of full vectorized system: N^2 for Lindblad or N for Schroedinger, or -1 if not learning.
    int dim_hs;           // Dimension of the Hilbert space (N)
    int npulses;          // Number of pulses
    int npulses_local;    // Number of pulses on this processor
    int ninit;            // Number of initial conditions per pulse
    int ninit_local;      // Number of initial conditions per pulse on this processor
    bool densityData;     // true if reading density data from file

    double tstart;        /* Time stamp of the first data point [ns] */
    double tstop;         /* Time stamp of the last data point [ns] */
    double dt;             /* Sample rate of the data [ns] */
    std::vector<std::vector<std::vector<Vec>>> data; /* For each pulse_number: For each initial condition: List of states at each data time-step */

    std::vector<std::vector<double>> controlparams; /* Control parameters. Could be empty (if synthetic data), or 2 values (if constant p and q), or a list of bspline parameters (if random pulses) */

    MPI_Comm comm_optim;
    MPI_Comm comm_init;
    int mpirank_optim;
    int mpisize_optim;
    int mpirank_world;
    int mpisize_world;
    int mpirank_init;
    int mpisize_init;

	public:
    Data();
    Data(Config config, MPI_Comm comm_optim_, MPI_Comm comm_init_, int ninit_, std::vector<std::string>& data_name, std::vector<int> nlevels_, LindbladType lindbladtype_, bool densityData_);
    virtual ~Data();

    int getNTime() { return data[0][0].size(); }; // get number of time steps in the data
    double getDt(){ return dt; };
    double getTStart(){ return tstart; };
    double getTStop(){ return tstop; };
    double getNPulses(){ return npulses; };
    double getNPulses_local(){ return npulses_local; };
    double getNInit(){ return ninit; };
    double getNInit_local(){ return ninit_local; };

    bool isDensityData(){ return densityData;};
    int getDim(){ return dim; };
    int getDim_hs(){ return dim_hs; };
    
    /* Suggest a time-step size that matches to the data sampling (is an integer divisor of the data sampling rate and that is close to dt_old */
    double suggestTimeStepSize(double dt_old);

    /* Get control parameters that were used for data generation. Note: pulse_num is global. */
    std::vector<double> getControls(int ipulse_global); 

    /* If data point exists at this time, return it. Otherwise, returns NULL. Note: pulse_num is the global counter. */
    Vec getData(double time, int ipulse_global, int iinit_global);

    /* Write expected energy of a data trajectory to file */
    void writeExpectedEnergy(const char* filename, int ipulse_global, int iinit_global, int ioscillator);

    /* Write full density matrix of a data trajectory to files */
    void writeFullstate(const char* filename_Re, const char* filename_Im, int ipulse_global, int iinit_global);
};

/* Class for density matrix data generated by Quandary simulations - any number of levels */
class SyntheticRhoQuandaryData : public Data {
  public:
    SyntheticRhoQuandaryData (Config config, MPI_Comm comm_optim, MPI_Comm comm_init_, int ninit_, std::vector<std::string>& data_name, std::vector<int> nlevels, LindbladType lindbladtype_, bool densityData_);
    ~SyntheticRhoQuandaryData ();

    /* Loads data and sets first and last time point as well as sampling step size */
    void loadData(std::vector<std::string>& data_name, double* tstart, double* tstop, double* dt);
};

/* Class for synthetic population data, generated by Quandary*/
class SyntheticPopQuandaryData : public Data {
  public:
    SyntheticPopQuandaryData (Config config, MPI_Comm comm_optim, MPI_Comm comm_init_, int ninit_, std::vector<std::string>& data_name, std::vector<int> nlevels, LindbladType lindbladtype_, bool densityData_);
    ~SyntheticPopQuandaryData ();

    /* Loads data and sets first and last time point as well as sampling step size */
    void loadPopData(std::vector<std::string>& data_name, double* tstart, double* tstop, double* dt);
};


/* Class for data generated on Tant with 2level measurement operators. Compatible with database 231110_SG_Tant_2level */
class Tant2levelData : public Data {
  protected:
    int nshots;    /* Number of shots */
    bool corrected;  /* If true, using physical density matrices */

  public:
    Tant2levelData(Config config, MPI_Comm comm_optim, MPI_Comm comm_init_, int ninit_, std::vector<std::string>& data_name, std::vector<int> nlevels, LindbladType lindbladtype_, bool densityData_);
    ~Tant2levelData();

    /* Loads data and sets first and last time point as well as sampling step size */
    void loadData(std::vector<std::string>& data_name, double* tstart, double* tstop, double* dt);
};

/* Class for data generated on Tant with 3 level measurement operators. Compatible with database 240711/ and 240715/ */
class Tant3levelData : public Data {
  protected:
    bool corrected;  /* If true, using physical density matrices */

  public:
    Tant3levelData(Config config, MPI_Comm comm_optim, MPI_Comm comm_init_, int ninit_, std::vector<std::string>& data_name,  std::vector<int> nlevels, LindbladType lindbladtype_, bool densityData_);
    ~Tant3levelData();

    /* Loads data and sets first and last time point as well as sampling step size */
    void loadData(std::vector<std::string>& data_name, double* tstart, double* tstop, double* dt);
};