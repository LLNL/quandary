import pytest
import numpy as np
from pytest import approx
from quandary import Quandary

# Mark all tests in this file as regression tests
pytestmark = pytest.mark.regression

REL_TOL = 1.0e-3
ABS_TOL = 1.0e-10

# Sample every 100 time steps
SAMPLE_STEP = 100
SAMPLE_INDICES = list(range(0, 1000, SAMPLE_STEP))

EXPECTED_INFIDELITY = 9.579442993001841e-05

EXPECTED_PT = [
    [
        6.616725193332, -2.69000519001337, 7.37277813386157, -3.74776129300963, -6.84027288145787,
        -11.3843214681583, 22.9942959921893, -12.5735054683736, 16.340616616697098, 5.03169262640028
    ],
    [
        41.115114703615404, 6.20339346604496, -57.143070676365696, 47.8892790887547, -14.8666376642723,
        12.2136130909702, -100.26207561761501, 162.83351141781998, -75.9622207062174, -72.1202107523129
    ],
]

EXPECTED_QT = [
    [
        12.2046682803128, -8.079881699053109, 16.4875320760023, -5.461025628965721, 11.1234357226862,
        -12.7826810046159, 0.147440839329306, 22.7946487720523, -10.3817628748433, -7.76762358999419
    ],
    [
        -42.4224419634531, 154.38104118826502, -106.09535149239501, -47.3984982589973, 137.734223043753,
        -126.00428091818799, 63.2898514048737, -31.3690850739396, 78.0954617941575, -64.22668926201
    ],
]

EXPECTED_ENERGY = [
    [
        [
            0.0, 0.0343776867606554, 0.526796763769277, 0.780954240543288, 0.866125816361883,
            0.960524117458703, 0.357409349352425, 0.0855357085561291, 0.0452846026271667, 0.521501498149395
        ],
        [
            0.0, 0.0469063275861075, 0.509147153889098, 0.756960458910116, 0.839965243568155,
            0.967039095793251, 0.281757944150766, 0.0875800293040959, 0.0333098058877516, 0.359796138200774
        ],
        [
            1.0, 0.965563423724401, 0.467777024255108, 0.199218651155181, 0.124914718210749,
            0.0424256184064999, 0.73355546218628, 0.923072091142331, 0.975849082136768, 0.64319313982527
        ],
        [
            1.0, 0.953152562102101, 0.496279057642638, 0.262866649149181, 0.168994221944719,
            0.0300111684909359, 0.627277244373336, 0.90381217136351, 0.945556509484767, 0.475509224112312
        ],
    ],
    [
        [
            0.0, 0.831977237672821, 0.191357346184574, 0.625910716277095, 0.937379902798678,
            0.00963598916620533, 0.179106523427556, 0.670087999937763, 0.763978679766654, 0.0544493184467886
        ],
        [
            1.0, 0.167523903453768, 0.811130164498519, 0.361501635864612, 0.0500738912924525,
            0.996953036235878, 0.813633790190331, 0.322484955601581, 0.236119318537149, 0.942765139557318
        ],
        [
            0.0, 0.722645324846759, 0.381156069703124, 0.27076601420254, 0.587949469059606,
            0.306348721091516, 0.638755583149189, 0.939883877428134, 0.742650628373161, 0.829280585662997
        ],
        [
            1.0, 0.277853534003518, 0.616356419650465, 0.741821633765665, 0.424596736918113,
            0.687062253461252, 0.368504103524597, 0.0675431672219572, 0.257251373411591, 0.173504956452293
        ],
    ],
]

EXPECTED_POPULATION = [
    [
        [
            1.0, 0.96562231323944, 0.473203236234554, 0.219045759462923, 0.133874183644436,
            0.0394758825489966, 0.642590650656231, 0.914464291453796, 0.954715397383493, 0.478498501862085
        ],
        [
            1.0, 0.953093672413988, 0.490852846114757, 0.243039541097649, 0.160034756439763,
            0.0329609042160594, 0.718242055858744, 0.912419970707285, 0.966690194125127, 0.640203861813051
        ],
        [
            0.0, 0.0344365762757087, 0.532222975748686, 0.800781348850533, 0.875085281795089,
            0.957574381600628, 0.266444537821086, 0.0769279088670572, 0.0241509178738421, 0.356806860185867
        ],
        [
            0.0, 0.0468474378979889, 0.503720942360812, 0.737133350856038, 0.83100577806066,
            0.969988831515816, 0.372722755633689, 0.0961878286455842, 0.0544434905259422, 0.524490775899009
        ],
    ],
    [
        [
            1.0, 0.168022762327275, 0.808642653819256, 0.374089283729116, 0.0626200972076404,
            0.990364010841494, 0.8208934765811, 0.329912000072162, 0.236021320244006, 0.945550681564691
        ],
        [
            0.0, 0.832476096546328, 0.188869835505336, 0.638498364143153, 0.949926108715465,
            0.00304696377343223, 0.186366209819179, 0.6775150444098, 0.76388068147573, 0.0572348604565071
        ],
        [
            1.0, 0.277354675153351, 0.61884393030067, 0.729233985803174, 0.412050530946231,
            0.693651278915612, 0.361244416858177, 0.0601161225812547, 0.25734937163745, 0.17071941434814
        ],
        [
            0.0, 0.722146465996572, 0.383643580352985, 0.258178366239553, 0.575403263087266,
            0.312937746545499, 0.631495896482428, 0.932456832787137, 0.742748626599118, 0.826495043559029
        ],
    ],
]


def test_example_cnot(mpi_exec):
    """Test CNOT gate optimization using Python interface."""

    freq01 = [4.80595, 4.8601]
    favg = sum(freq01)/len(freq01)
    rotfreq = favg*np.ones(len(freq01))
    unitary = np.identity(4)
    unitary[2, 2] = 0.0
    unitary[3, 3] = 0.0
    unitary[2, 3] = 1.0
    unitary[3, 2] = 1.0
    n_osc = 2
    n_levels = 4

    quandary = Quandary(
        freq01=freq01,
        Jkl=[0.005],
        rotfreq=rotfreq,
        T=200.0,
        targetgate=unitary,
        verbose=False,
        randomize_init_ctrl=False,
    )

    t, pt, qt, infidelity, expectedEnergy, population = quandary.optimize(
        mpi_exec=mpi_exec,
        maxcores=2
    )

    assert t[0] == 0.0 and t[-1] == 200.0
    assert len(t) == 1222
    assert infidelity == approx(EXPECTED_INFIDELITY, rel=REL_TOL, abs=ABS_TOL)

    for i in range(n_osc):
        pt_samples = [pt[i][idx] for idx in SAMPLE_INDICES]
        qt_samples = [qt[i][idx] for idx in SAMPLE_INDICES]
        np.testing.assert_allclose(pt_samples, EXPECTED_PT[i], rtol=REL_TOL, atol=ABS_TOL)
        np.testing.assert_allclose(qt_samples, EXPECTED_QT[i], rtol=REL_TOL, atol=ABS_TOL)

    for i in range(n_osc):
        for j in range(n_levels):
            energy_data = expectedEnergy[i][j]
            energy_samples = [energy_data[idx] for idx in SAMPLE_INDICES]
            np.testing.assert_allclose(energy_samples, EXPECTED_ENERGY[i][j], rtol=REL_TOL, atol=ABS_TOL)

            pop_data = population[i][j]
            pop_samples = [pop_data[0, idx] for idx in SAMPLE_INDICES]
            np.testing.assert_allclose(pop_samples, EXPECTED_POPULATION[i][j], rtol=REL_TOL, atol=ABS_TOL)
