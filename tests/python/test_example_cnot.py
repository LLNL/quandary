import pytest
import numpy as np
from quandary import Quandary

# Mark all tests in this file as regression tests
pytestmark = pytest.mark.regression

REL_TOL = 1.0e-3
ABS_TOL = 1.0e-10

# Sample every 100 time steps
SAMPLE_STEP = 100
SAMPLE_INDICES = list(range(0, 1000, SAMPLE_STEP))

EXPECTED_PT = [
    [
        3.9658691461922495, 1.10541078504851, 2.5534752325083, -5.01459964111086, -7.989518198565721,
        19.8647450324926, -11.67803451432, 9.83064584558409, -4.38133012164486, 5.30730946469264
    ],
    [
        31.2400305710471, -66.08853683466239, -0.465091455341277, 63.7248265188924, -21.174310603939798,
        -79.05665721270739, 93.1340069390719, -46.9030952418057, 69.6982899074631, -75.945333755
    ],
]

EXPECTED_QT = [
    [
        9.862252388043519, -11.974045135091401, 6.59606355642564, 0.470220730556019, -6.96238968454898,
        1.44683564000136, 1.3431283726069598, 7.88787484285384, -10.6057026529729, 4.61727211900083
    ],
    [
        -24.7819518399261, 84.1878324773596, -57.286612404866005, 60.7002321574017, -81.5873538588084,
        24.5564679603065, 70.41021934650581, -24.027297723508998, -69.5540861506332, 58.1373379857519
    ],
]

EXPECTED_ENERGY = [
    [
        [
            0.0, 0.0443127685743886, 0.503207525241488, 0.707485513252159, 0.92190965075134,
            0.487452233057886, 0.0659189040310057, 0.404806229139373, 0.621700867282782, 0.418405398025964
        ],
        [
            0.0, 0.0427783016984607, 0.405600998566902, 0.72910738824454, 0.913321148985495,
            0.501596986810575, 0.117409347015588, 0.295738092810018, 0.62534755580572, 0.391835768771235
        ],
        [
            1.0, 0.952870578107849, 0.51330421156213, 0.231076804756971, 0.0469090316748128,
            0.523616466963615, 0.902254320190267, 0.715768042541915, 0.374775615666352, 0.609611191500487
        ],
        [
            1.0, 0.960038351404126, 0.577887263952844, 0.332330293674496, 0.117860168444146,
            0.487334313786966, 0.914417429110783, 0.58368763524068, 0.378175961322588, 0.580147642107814
        ],
    ],
    [
        [
            0.0, 0.114473223136999, 0.89365412503045, 0.125033950995173, 0.169036787529785,
            0.720428927135866, 0.976681894430636, 0.779086542498037, 0.969638523760001, 0.806602690681456
        ],
        [
            1.0, 0.880738445400608, 0.111681881442643, 0.896846315383814, 0.83845895823167,
            0.28684021932136, 0.0301558855495244, 0.22954869411915, 0.026841345557848, 0.19354082356098
        ],
        [
            0.0, 0.234235386928253, 0.625339960381513, 0.447433990734819, 0.177530699064567,
            0.0793832709583276, 0.373058049086058, 0.0378220594045343, 0.0605571768789592, 0.114455321435803
        ],
        [
            1.0, 0.770552944580204, 0.369324033000151, 0.530685742874723, 0.814973555117265,
            0.913347582445915, 0.620104170694281, 0.953542703675033, 0.942962953633296, 0.885401164374174
        ],
    ],
]

EXPECTED_POPULATION = [
    [
        [
            1.0, 0.955687231426092, 0.496792474760431, 0.292514486752091, 0.0780903492531091,
            0.512547766947759, 0.934081095976383, 0.595193770868252, 0.378299132726335, 0.581594601984949
        ],
        [
            1.0, 0.957221698302315, 0.594399001435299, 0.270892611759853, 0.0866788510192543,
            0.498403013196075, 0.88259065299362, 0.704261907199483, 0.374652444205939, 0.608164231242167
        ],
        [
            0.0, 0.0471294218930485, 0.486695788440728, 0.768923195249066, 0.953090968331444,
            0.476383533045079, 0.0977456798208405, 0.284231957469638, 0.625224384347882, 0.390388808515223
        ],
        [
            0.0, 0.0399616485968552, 0.422112736049773, 0.667669706330358, 0.882139831561034,
            0.512665686222864, 0.0855825709022572, 0.416312364772957, 0.621824038693774, 0.419852357910149
        ],
    ],
    [
        [
            1.0, 0.885526776863482, 0.106345874971468, 0.874966049009077, 0.830963212474665,
            0.279571072869779, 0.0233181055767533, 0.220913457509588, 0.0303614762491157, 0.193397309329457
        ],
        [
            0.0, 0.119261554600168, 0.888318118559558, 0.103153684620578, 0.16154104177308,
            0.713159780685289, 0.969844114459683, 0.77045130589035, 0.973158654453811, 0.806459176452422
        ],
        [
            1.0, 0.765764613072644, 0.374660039621344, 0.552566009271218, 0.822469300941689,
            0.920616729050366, 0.626941950925049, 0.962177940607019, 0.939442823135274, 0.885544678579907
        ],
        [
            0.0, 0.229447055420778, 0.630675967002465, 0.469314257130131, 0.185026444887915,
            0.086652417563915, 0.379895829318759, 0.0464572963386036, 0.0570370463830656, 0.114598835643788
        ],
    ],
]


def test_example_cnot(mpi_exec):
    """Test CNOT gate optimization using Python interface."""

    freq01 = [4.80595, 4.8601]
    favg = sum(freq01)/len(freq01)
    rotfreq = favg*np.ones(len(freq01))
    unitary = np.identity(4)
    unitary[2, 2] = 0.0
    unitary[3, 3] = 0.0
    unitary[2, 3] = 1.0
    unitary[3, 2] = 1.0
    n_osc = 2
    n_levels = 4

    quandary = Quandary(
        freq01=freq01,
        Jkl=[0.005],
        rotfreq=rotfreq,
        T=200.0,
        targetgate=unitary,
        verbose=False,
        randomize_init_ctrl=False,
        nsteps=1000,
        dT=0.2,
    )

    t, pt, qt, infidelity, expectedEnergy, population = quandary.optimize(
        mpi_exec=mpi_exec,
        maxcores=2
    )

    assert t[0] == 0.0 and t[-1] == 200.0
    assert infidelity < 1e-4

    for i in range(n_osc):
        pt_samples = [pt[i][idx] for idx in SAMPLE_INDICES]
        qt_samples = [qt[i][idx] for idx in SAMPLE_INDICES]
        np.testing.assert_allclose(pt_samples, EXPECTED_PT[i], rtol=REL_TOL, atol=ABS_TOL)
        np.testing.assert_allclose(qt_samples, EXPECTED_QT[i], rtol=REL_TOL, atol=ABS_TOL)

    for i in range(n_osc):
        for j in range(n_levels):
            energy_data = expectedEnergy[i][j]
            energy_samples = [energy_data[idx] for idx in SAMPLE_INDICES]
            np.testing.assert_allclose(energy_samples, EXPECTED_ENERGY[i][j], rtol=REL_TOL, atol=ABS_TOL)

            pop_data = population[i][j]
            pop_samples = [pop_data[0, idx] for idx in SAMPLE_INDICES]
            np.testing.assert_allclose(pop_samples, EXPECTED_POPULATION[i][j], rtol=REL_TOL, atol=ABS_TOL)
