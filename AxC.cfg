#################################################
# Parallelization: np_braid * np_init * np_petsc = size(MPI_COMM_WORLD)
#################################################
// Number of processes for distrubuting the initial conditions (np_init) and xbraid (np_braid).
np_init = 9
np_braid = 1

##################
# Testcase 
##################
// Number of levels per each oscillator.
nlevels = 3, 20
// Number of time steps
ntime = 10000
// Time step size 
dt = 0.0001
// Number of spline function per oscillator (total number of optimization variables will be 2*nspline*noscillators).
nspline = 30
// Drift Hamiltonian frequencies xi for all oscillators and their coupling terms (will be multiplied by 2*PI)
// Format: x = [xi_0, x_01, x_02,...,x_1, x_12,....] -> number of elements here should be (noscillators+1)*noscillators/2 !
xi = 225.6, 1.0, 0.0
// Internal frequencies per oscillator (will be multiplied by 2*PI)
frequencies = 4099.47, 7076.8
// Carrier wave frequencies. One line per oscillator 0..Q-1. (will be multiplied by -2*PI)
carrier_frequency0 = 0.0, 225.6
carrier_frequency1 = 0.0
// Lindblad collapse type: "none", "decay", "dephase" or "both"
lindblad_type = decay
// Collapse times T1, T2 per oscillator (gamma_l = 1/T_l, l=1,2). Format [T1_oscil1, T2_oscli1, T1_oscil2, T2_oscil2, ...]
lindblad_collapsetime = 30.0, 0.0, 0.1136, 0.0
// Specify the initial conditions: 
// "file, /path/to/file"  - read one specific initial condition from file (Format: one column of length 2N^2 containing vectorized density matrix, first real part, then imaginary part), 
// "pure, <list, of, unit, vecs, per, oscillator>" - init with kronecker product of pure vectors, e.g. "pure, 1,0" sets the initial state |1><1| \otimes |0><0|
// "diagonal, <list, of, oscillator, IDs>" - all unit vectors that correspond to the diagonal of the (full or reduced) density matrix for the subsystem defined by the list of oscillator IDs.
// "basis, <list, of, oscillator, IDs>" - basis for the (full or reduced) density matrix for the subsystem defined by the list of oscillator IDs.
#initialcondition = basis, 0
#initialcondition = diagonal, 0
#initialcondition = file, ./initcond/AxC_rho0.dat
initialcondition=pure, 2,0

##################
# Braid options 
##################
// Maximum  number of time grid levels (maxlevels = 1 runs sequential forward simulation, e.g. no braid)
braid_maxlevels = 1
// Coarsening factor
braid_cfactor = 5
// Level of braid screen output. 0 - no output, 1 - convergence history, higher numbers: compare with xbraid doc
braid_printlevel = 1
// Maximum number of braid iterations per optimization cycle
braid_maxiter = 20 
// Absolute stopping tolerance
braid_abstol = 1e-5
// Relative stopping tolerance
braid_reltol = 1e-4
// Turn on/off full multigrid cycle. This is costly, but convergence typically improves.
braid_fmg     = true
// Skip computation on first downcycle
braid_skip    = false
// Decide how often the state will be written to a file. 0 - never, 1 - once after each braid run // TODO: only after optimization finishes
braid_accesslevel = 1

#######################
# Optimization options 
#######################
// Specify the objective function: "gate, <type>" where <type> can be "cnot", "xgate", "ygate", "zgate" or "hadamard": compares final state to gate-transformed initial conditions. "expectedEnergy" minimizes expected energy levels of (full or reduced) density matrix. Or "groundstate" compares (full or reduced) density matrix to groundstate density matrix.
optim_objective = expectedEnergy
// Specify the oscillator ID's that are considered by the objective function: "all" to consider full density matrix or a list of consecutive integers, e.g. "0,1,2" or "3,4" to consider a reduced matrix for those oscillators. 
optim_oscillators = all
optim_weights = 20.0, 1.0
#optim_oscillators = 0
// Initial control parameters: "constant" initializes with constant amplitudes, "random" initializes with random amplitudes (fixed seed), "random_seed" same but using a random seed, "/path/to/file/" reads initial paramters from file
optim_init = random
// Initial control parameter amplitudes for each oscillator. If random initialization, these amplitudes are maximum bounds for the random number generator
optim_init_ampl = 1.55500902, 8.88576587
// Specify bounds for the absolute control function amplitudes per oscillator
optim_bounds = 15.0, 20000.0
// Optimization stopping tolerance (absolute: ||G|| < atol )
optim_atol     = 1e-7
// Optimization stopping tolerance (relative: ||G||/||G0|| < rtol )
optim_rtol     = 1e-8
// Maximum number of optimization iterations
optim_maxiter = 200
// Coefficient of Tikhonov regularization for the design variables (gamma/2 || design ||^2)
optim_regul   = 0.00001
// Coefficient for adding integral penalty term (gamma \int_0^T (t/T)^p J(rho(t)) dt )
optim_penalty = 0.0
// integral penalty exponent p
optim_penalty_exponent = 2
// frequency of writing output during optimization: write output every <num> iterations
optim_outputfrequency = 10

######################
# Output and runtypes
######################
// Directory for output files
datadir = ./data_out
// Specify the desired output for each oscillator (list of options: "expectedEnergy" - expected energy level, "population" - population (diagonal of reduced density matrix), "fullstate" - full density matrix of the coupled system (can appear in any of the oscillators)
output0 = expectedEnergy
output1 = expectedEnergy
// Runtype options: "primal" - forward simulation only, "adjoint" - forward and backward, or "optimization" - run optimization
runtype = primal
// Use matrix free solver, instead of sparse matrix implementation. Currently implemented ony for 2 Oscillators.
usematfree = true
// Use Petsc's timestepper, or use home-brewed time stepper (-> MidPointRule)
usepetscts = false
// Switch for monitoring Petc's timestepper
monitor = false
// Choose linear solver, eighter 'gmres' for using Petsc's GMRES solver (preferred), or 'neumann' for using Neumann series iterations to solve the linear system
linearsolver_type = gmres
// Set maximum number of iterations for the linear solver
linearsolver_maxiter = 20
