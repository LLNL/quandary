##################
# Testcase 
##################
// Number of levels per subsystem
nlevels = 3, 20
// Number of essential levels per subsystem (Default: Same as number of levels, comment out if not used). 
nessential = 3, 20
// Number of time steps
ntime = 10000
// Time step size (us)
dt = 0.0001
// Fundamental transition frequencies (|0> to |1> transition) for each oscillator ("\omega_k", multiplying a_k^d a_k,  MHz, will be multiplied by 2*PI)
transfreq = 4416.66, 6840.815
// Self-kerr frequencies for each oscillator ("\xi_k", multiplying a_k^d a_k^d a_k a_k,  MHz, will be multiplied by 2*PI)
selfkerr = 230.56, 0.0
// Cross-kerr coupling frequencies for each oscillator coupling k<->l ("\xi_kl", multiplying a_k^d a_k a_l^d a_l, MHz, will be multiplied by 2*PI)
// Format: x = [x_01, x_02,...,x_12, x_13....] -> number of elements here should be (noscillators-1)*noscillators/2 !
crosskerr = 1.176
// Jaynes-Cummings coupling frequencies for each oscillator coupling k<->l ("J_kl", multiplying a_k^d a_l + a_k a_l^d, MHz, will be multiplied by 2*PI)
// Format Jkl = [J_01, J_02, ..., J12, J13, ...] -> number of elements are (noscillators-1)*noscillators/2
Jkl = 1.7176618675897612e-3
// Rotational wave approximation frequencies for each subsystem  ("\omega_rot", MHz, will be multiplied by 2*PI)
// Note: The rotation of a target *gate* can be given separately with the "gate_rot_freq" option, see below.
rotfreq = 4416.66, 6840.815 
// Decide which Lindblad collapse operators are taken into account: "none", "decay", "dephase" or "both"
// Note that choosing 'none' here will solve Schroedinger's equation for the state vector, vs. all other choices will solve Lindblad's master equation for the density matrix!
collapse_type = both
// Time of decay collapse operation (T1) per oscillator (gamma_1 = 1/T_1) (only active if 'collapse_type' is NOT 'none')
// Note that setting collapse times to 0.0 for decay and/or dephasing will omit the evaluation of the corresponding terms inside the the Lindbladian operator. Therefore, choosing 0.0 here together with any other choice than "none" for the collapse_type, will still solve Lindblad's equation for the density matrix (!). If you want to use Schroedingers solver for the state vector (!), choose 'collapse_type=none'.
decay_time = 80.0, 0.3892042
// Time of dephase collapse operation (T2) per oscillator (gamma_2 = 1/T_2) (only active if 'collapse_type' is NOT 'none')
dephase_time = 26.0, 0.0
// Specify the initial conditions: 
//
// "file, /path/to/file" - read one specific initial condition from file (Format: one column containing the state vector or the vectorized density matrix, first all real elements, then all imaginary elements, length of the file must be 2N (for state vector) or 2N^2 (for vectorized density matrix))
// "pure, <list, of, unit, vecs, per, oscillator>" - init with kronecker product of pure vectors, e.g. "pure, 1,0" sets the initial state |1> \otimes |0> 
// "ensemble, <list, of, oscillator, IDs>" - ensemble state for the subsystems indicated by the list of oscillators, ground state for the other oscillators
// "diagonal, <list, of, oscillator, IDs>" - all unit vectors that correspond to the diagonal of the (full or reduced) density matrix for the subsystem defined by the list of oscillator IDs.
// "basis, <list, of, oscillator, IDs>" - basis for the (full or reduced) density matrix for the subsystem defined by the list of oscillator IDs.
// "3states"  - uses the three specific initial states from C. Koch's paper for gate optimization ("Optimal control theory for a unitary operation under dissipative evolution", New Journal of Physics, 2014)
// "Nplus1"   - N+1 initial conditions from C. Koch's paper for gate optimization ("Optimal control theory for a unitary operation under dissipative evolution", New Journal of Physics, 2014)
#initialcondition = basis, 0
#initialcondition = diagonal, 0
#initialcondition = file, ./initcond/alice_sumbasis.dat
initialcondition = ensemble, 0
#initialcondition = pure, 2, 0
#initialcondition = 3states
#initialcondition = Nplus1
// Apply a pi-pulse to oscillator <oscilID> from <tstart> to <tstop> using a control strength of <amp> rad/us. This ignores the code's control parameters inside [tstart,tstop], and instead applies the constant control amplitude |p+iq|=<amp> to oscillator <oscilID>, and zero control for all other oscillators.
// Format per pipulse: 4 values: <oscilID (int)>, <tstart (double)>, <tstop (double)>, <amp(double)>
// For more than one pipulse, just put them behind each other. I.e. number of elements here should be integer multiple of 4. For example either of the following lines:
#apply_pipulse = 0, 0.5, 0.604, 15.10381
#apply_pipulse = 0, 0.5, 0.604, 15.10381, 1, 0.7, 0.804, 15.10381

#######################
# Optimization options 
#######################
// Number of spline basis functions per oscillator control
nspline = 30
// Carrier wave frequencies. One line per oscillator 0..Q-1. (MHz, will be multiplied by 2*PI)
carrier_frequency0 = 0.0, -230.56
carrier_frequency1 = 0.0
// Specify the optimization target state \rho(T):
// "gate, <type>" where <type> can be "cnot", "cqnot", "swap", swap0q", "xgate", "ygate", "zgate" or "hadamard": the target state is the gate-transformed initial conditions. 
// "pure, <m1>, <m2>, ... , <mQ>"  - prepare the pure state |m1 m2 m3 ... mQ>. Note: Each oscillators pure target state is separated by commas!
// "file, /path/to/file" - read a target state from file (Format: one column containing the state vector or the vectorized density matrix, first all real elements, then all imaginary elements, length of the file must be 2N (for state vector) or 2N^2 (for vectorized density matrix))
optim_target = pure, 0, 0
// Specify the objective function
// "Jfrobenius", "Jtrace", or "Jmeasure"
optim_objective = Jmeasure
// If optimization target is a gate, specify the gate rotation frequencies (MHz, will be multiplied by 2*PI). By default, those are the rotational frequencies of the system, so commenting out this line ensures that gate rotation matches the rotational frame frequencies. Otherwise, they can be set differently here, e.g. 0.0, 0.0,... for Lab frame gate. 
// Format: one number per oscillator. If less numbers are given, the *last* one will be used to all remaining oscillators.
gate_rot_freq = 0.0
// Weights for summing over initial conditions in objective function (beta_i). Format: list of values separated by comma. If less values than initial conditions are given, the *last* value will be used for the remaining initial conditions. 
optim_weights = 1.0
// Initial control parameters: "constant" initializes with constant amplitudes, "random" initializes with random amplitudes (fixed seed), "random_seed" same but using a random seed, "/path/to/file/" reads initial paramters from file
optim_init = constant
// Initial control parameter amplitudes for each oscillator, if constant initialization. If random initialization, these amplitudes are maximum bounds for the random number generator
optim_init_ampl = 1.0, 5.0
// Specify bounds for the absolute control function amplitudes per oscillator (rad/us)
optim_bounds = 15.0, 20000.0
// Optimization stopping tolerance (absolute: ||G|| < atol )
optim_atol     = 1e-7
// Optimization stopping tolerance (relative: ||G||/||G0|| < rtol )
optim_rtol     = 1e-8
// Maximum number of optimization iterations
optim_maxiter = 200
// Coefficient (gamma_2) of Tikhonov regularization for the design variables (gamma_2/2 || design ||^2)
optim_regul   = 0.00001
// Coefficient (gamma_1) for adding integral penalty term (gamma_1 \int_0^T P(rho(t) dt )
optim_penalty = 0.0
// integral penalty parameter inside the weight in P(rho(t)) (gaussian variance a)
optim_penalty_param = 0.5

######################
# Output and runtypes
######################
// Directory for output files
datadir = ./data_out
// Specify the desired output for each oscillator, one line per oscillator. Format: list of either of the following options: 
//"expectedEnergy" - expected energy level for each time step, 
//"population" - energy level population at each time step
//"fullstate" - full state of the composite system (full density matrix, or state vector) (note: 'fullstate' can appear in *any* of the lines). WARNING: This might result in *huge* output files! Use with care.
output0 = expectedEnergy, population
output1 = expectedEnergy
// Output frequency in the time domain: write output every <num> time-step (num=1 writes every time step)
output_frequency = 1
// Frequency of writing output during optimization: write output every <num> optimization iterations. 
optim_monitor_frequency = 5
// Runtype options: "simulation" - runs a forward simulation only, "gradient" - forward simulation and gradient computation, or "optimization" - run an optimization
runtype = simulation
// Use matrix free solver, instead of sparse matrix implementation. 
usematfree = true
// Solver type for solving the linear system at each time step, eighter 'gmres' for using Petsc's GMRES solver (preferred), or 'neumann' for using Neumann series iterations
linearsolver_type = gmres
// Set maximum number of iterations for the linear solver
linearsolver_maxiter = 20

#################################################
# Parallel execution: 
# MAKE SURE THAT np_braid * np_init * np_petsc = size(MPI_COMM_WORLD) 
# and that np_init matches the chosen option for 'initialcondition'!! 
# Parallel petsc (np_petsc>1) works only with for the sparse-matrix solver.
#################################################
// Number of processes for distrubuting the initial conditions (np_init) and xbraid (np_braid). The remaining processors (=size(MPI_COMM_WORLD)/(npinit*npbraid) will be used to parallelize petsc. 
np_init = 1
np_braid = 1

#######################
# XBraid options 
# Experimental. Leave as is.
#######################
// Maximum  number of time grid levels (maxlevels = 1 runs sequential simulation, i.e. no xbraid)
braid_maxlevels = 1
// Coarsening factor
braid_cfactor = 5
// Level of braid screen output. 0 - no output, 1 - convergence history, higher numbers: compare with xbraid doc
braid_printlevel = 1
// Maximum number of braid iterations per optimization cycle
braid_maxiter = 20 
// Absolute stopping tolerance
braid_abstol = 1e-5
// Relative stopping tolerance
braid_reltol = 1e-4
// Turn on/off full multigrid cycle. This is costly, but convergence typically improves.
braid_fmg     = true
// Skip computation on first downcycle
braid_skip    = false
// Decide how often the state will be written to a file. 0 - never, 1 - once after each braid run // TODO: only after optimization finishes
braid_accesslevel = 1
