##################
# Testcase 
##################
// Number of levels per subsystem
nlevels = 2, 2, 2, 2, 2, 2, 2, 2
// Number of time steps
ntime = 1000
// Time step size (us)
dt = 0.01
// Fundamental transition frequencies (|0> to |1> transition) for each oscillator ("\omega_k", multiplying a_k^d a_k,  MHz, will be multiplied by 2*PI)
transfreq = 0.3183,0.3183,0.3183,0.3183,0.3183,0.3183,0.3183,0.3183,
// Self-kerr frequencies for each oscillator ("\xi_k", multiplying a_k^d a_k^d a_k a_k,  MHz, will be multiplied by 2*PI)
selfkerr = 0.0
// Cross-kerr coupling frequencies for each oscillator coupling k<->l ("\xi_kl", multiplying a_k^d a_k a_l^d a_l, MHz, will be multiplied by 2*PI)
crosskerr = 0.0
// Jaynes-Cummings coupling frequencies for each oscillator coupling k<->l ("J_kl", multiplying a_k^d a_l + a_k a_l^d, MHz, will be multiplied by 2*PI)
Jkl = 0.3183, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.3183, 0.0, 0.0, 0.0, 0.0, 0.0, 0.3183, 0.0, 0.0, 0.0, 0.0, 0.3183, 0.0, 0.0, 0.0, 0.3183, 0.0, 0.0, 0.3183, 0.0, 0.3183
// Rotational wave approximation frequencies for each subsystem  ("\omega_rot", MHz, will be multiplied by 2*PI)
rotfreq = 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
// Decide which Lindblad collapse operators are taken into account: "none", "decay", "dephase" or "both"
// Note that choosing 'none' here will solve Schroedinger's equation for the state vector, vs. all other choices will solve Lindblad's master equation for the density matrix!
collapse_type = none
// Specify the initial conditions: 
initialcondition = pure, 1, 1, 1, 1, 0, 0, 0, 0

#######################
# Optimization options 
#######################
// Specify the optimization target state \rho(T):
optim_target = pure, 0,0,0,0,0,0,0,0
// Number of spline basis functions per oscillator control
nspline = 10
// Carrier wave frequencies. One line per oscillator 0..Q-1. (MHz, will be multiplied by 2*PI)
carrier_frequency0 = 0.0
carrier_frequency1 = 0.0
carrier_frequency2 = 0.0
carrier_frequency3 = 0.0
carrier_frequency4 = 0.0
carrier_frequency5 = 0.0
carrier_frequency6 = 0.0
carrier_frequency7 = 0.0
carrier_frequency8 = 0.0
// Specify the objective function
// "Jfrobenius", "Jtrace", or "Jmeasure"
optim_objective = Jmeasure
// Initial control parameters: "constant" initializes with constant amplitudes, "random" initializes with random amplitudes (fixed seed), "random_seed" same but using a random seed, "/path/to/file/" reads initial paramters from file
optim_init = constant
// Initial control parameter amplitudes for each oscillator, if constant initialization. If random initialization, these amplitudes are maximum bounds for the random number generator
optim_init_ampl = 0.0, 0.0
// Specify bounds for the absolute control function amplitudes per oscillator (rad/us)
optim_bounds = 15.0, 20000.0
// Optimization stopping tolerance based on gradient norm (absolute: ||G|| < atol )
optim_atol     = 1e-7
// Optimization stopping tolerance based on gradient norm (relative: ||G||/||G0|| < rtol )
optim_rtol     = 1e-8
// Optimization stopping criterion based on the final time cost (absolute: J(T) < ftol)
optim_ftol = 1e-4
// Optimization stopping criterion based on the infidelity (absolute: 1-Favg < inf_tol)
optim_inftol = 1e-4
// Maximum number of optimization iterations
optim_maxiter = 200
// Coefficient (gamma_2) of Tikhonov regularization for the design variables (gamma_2/2 || design ||^2)
optim_regul   = 0.00001
// Coefficient (gamma_1) for adding integral penalty term (gamma_1 \int_0^T P(rho(t) dt )
optim_penalty = 0.0
// integral penalty parameter inside the weight in P(rho(t)) (gaussian variance a)
optim_penalty_param = 0.5

######################
# Output and runtypes
######################
// Directory for output files
datadir = ./data_out
// Specify the desired output for each oscillator, one line per oscillator. Format: list of either of the following options: 
//"expectedEnergy" - time evolution of expected energy level for this subsystem
//"population" - time evolution of state occupations (probabilities) for this subsystem 
//"fullstate" - time evolution of the full state of the composite system (full density matrix, or state vector) (note: 'fullstate' can appear in *any* of the lines). WARNING: This might result in *huge* output files! Use with care.
//"nhalf" - time evolution of the Nhalf measure for spin chain simulations (note: can appear in *any* of the lines)
//"magnetization" - time evolution of the magnetization measure for spin chain simulations (note: can appear in *any* of the lines)
output0 = expectedEnergy, population, nhalf, magnetization
output1 = expectedEnergy, population
output2 = expectedEnergy, population
output3 = expectedEnergy, population
output4 = expectedEnergy, population
output5 = expectedEnergy, population
output6 = expectedEnergy, population
output7 = expectedEnergy, population
output8 = expectedEnergy, population
// Output frequency in the time domain: write output every <num> time-step (num=1 writes every time step)
output_frequency = 1
// Frequency of writing output during optimization: write output every <num> optimization iterations. 
optim_monitor_frequency = 1
// Runtype options: "simulation" - runs a forward simulation only, "gradient" - forward simulation and gradient computation, or "optimization" - run an optimization
runtype = simulation
// Use matrix free solver, instead of sparse matrix implementation. 
usematfree = false
// Solver type for solving the linear system at each time step, eighter 'gmres' for using Petscs GMRES solver (preferred), or 'neumann' for using Neumann series iterations
linearsolver_type = gmres
// Set maximum number of iterations for the linear solver
linearsolver_maxiter = 20
gate_rot_freq=0.0

#################################################
# Parallel execution: 
# MAKE SURE THAT np_braid * np_init * np_petsc = size(MPI_COMM_WORLD) 
# and that np_init matches the chosen option for 'initialcondition'!! 
# Parallel petsc (np_petsc>1) works only with for the sparse-matrix solver.
#################################################
// Number of processes for distrubuting the initial conditions (np_init) and xbraid (np_braid). The remaining processors (=size(MPI_COMM_WORLD)/(npinit*npbraid) will be used to parallelize petsc. 
np_init = 1
np_braid = 1
