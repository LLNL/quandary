##################
# Testcase 
##################
// Number of levels per subsystem
nlevels = 2, 2, 2, 2, 2, 2, 2, 2
// Number of time steps
ntime = 1000
// Time step size (us)
dt = 0.01
// Fundamental transition frequencies (|0> to |1> transition) for each oscillator ("\omega_k", multiplying a_k^d a_k,  MHz, will be multiplied by 2*PI)
transfreq = 0.3183,0.3183,0.3183,0.3183,0.3183,0.3183,0.3183,0.3183,
// Self-kerr frequencies for each oscillator ("\xi_k", multiplying a_k^d a_k^d a_k a_k,  MHz, will be multiplied by 2*PI)
selfkerr = 0.0
// Cross-kerr coupling frequencies for each oscillator coupling k<->l ("\xi_kl", multiplying a_k^d a_k a_l^d a_l, MHz, will be multiplied by 2*PI)
crosskerr = 0.0
// Jaynes-Cummings coupling frequencies for each oscillator coupling k<->l ("J_kl", multiplying a_k^d a_l + a_k a_l^d, MHz, will be multiplied by 2*PI)
// Format Jkl = [J_01, J_02, ..., J12, J13, ...] -> number of elements are (noscillators-1)*noscillators/2
Jkl = 0.3183, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.3183, 0.0, 0.0, 0.0, 0.0, 0.0, 0.3183, 0.0, 0.0, 0.0, 0.0, 0.3183, 0.0, 0.0, 0.0, 0.3183, 0.0, 0.0, 0.3183, 0.0, 0.3183
// Rotational wave approximation frequencies for each subsystem  ("\omega_rot", MHz, will be multiplied by 2*PI)
rotfreq = 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
// Decide which Lindblad collapse operators are taken into account: "none", "decay", "dephase" or "both"
// Note that choosing 'none' here will solve Schroedinger's equation for the state vector, vs. all other choices will solve Lindblad's master equation for the density matrix!
collapse_type = none
decay_time = 0.0
dephase_time = 0.0
// Specify the initial conditions: 
initialcondition = pure, 1, 1, 1, 1, 0, 0, 0, 0

#######################
# Optimization options 
#######################
// Define the controllable segments for each oscillator. 
control_segments0 = none
ontrol_initialization0 = constant, 0.0
ontrol_bounds0 = 0.0
carrier_frequency0 = 0.0
// Specify the optimization target state \rho(T) (dummy)
optim_target = pure, 0, 0, 0, 0, 0, 0, 0, 0
// Specify the objective function
// "Jfrobenius", "Jtrace", or "Jmeasure"
optim_objective = Jmeasure
gate_rot_freq = 0.0
// Weighting the objective function contributions over initial conditions
optim_weights= 1.0
// Optimization stopping tolerance based on gradient norm (absolute: ||G|| < atol )
optim_atol     = 1e-7
// Optimization stopping tolerance based on gradient norm (relative: ||G||/||G0|| < rtol )
optim_rtol     = 1e-8
// Optimization stopping criterion based on the final time cost (absolute: J(T) < ftol)
optim_ftol = 1e-4
// Optimization stopping criterion based on the infidelity (absolute: 1-Favg < inf_tol)
optim_inftol = 1e-4
// Maximum number of optimization iterations
optim_maxiter = 200
// Coefficient (gamma_2) of Tikhonov regularization for the design variables (gamma_2/2 || design ||^2)
optim_regul   = 0.00001
// Coefficient (gamma_1) for adding integral penalty term (gamma_1 \int_0^T P(rho(t) dt )
optim_penalty = 0.0
// integral penalty parameter inside the weight in P(rho(t)) (gaussian variance a)
optim_penalty_param = 0.5

######################
# Output and runtypes
######################
// Directory for output files
datadir = ./data_out
// Specify the desired output for each oscillator, one line per oscillator. Format: list of either of the following options: 
//"expectedEnergy" - time evolution of expected energy level for this subsystem
//"population" - time evolution of state occupations (probabilities) for this subsystem 
//"fullstate" - time evolution of the full state of the composite system (full density matrix, or state vector) (note: 'fullstate' can appear in *any* of the lines). WARNING: This might result in *huge* output files! Use with care.
//"nhalf" - time evolution of the Nhalf measure for spin chain simulations (note: can appear in *any* of the lines)
//"magnetization" - time evolution of the magnetization measure for spin chain simulations (note: can appear in *any* of the lines)
output0 = expectedEnergy, population, nhalf, magnetization
output1 = expectedEnergy, population
output2 = expectedEnergy, population
output3 = expectedEnergy, population
output4 = expectedEnergy, population
output5 = expectedEnergy, population
output6 = expectedEnergy, population
output7 = expectedEnergy, population
output8 = expectedEnergy, population
// Output frequency in the time domain: write output every <num> time-step (num=1 writes every time step)
output_frequency = 1
// Frequency of writing output during optimization: write output every <num> optimization iterations. 
optim_monitor_frequency = 1
// Runtype options: "simulation" - runs a forward simulation only, "gradient" - forward simulation and gradient computation, or "optimization" - run an optimization
runtype = simulation
// Use matrix free solver, instead of sparse matrix implementation. 
usematfree = true
// Solver type for solving the linear system at each time step, eighter 'gmres' for using Petscs GMRES solver (preferred), or 'neumann' for using Neumann series iterations
linearsolver_type = gmres
// Set maximum number of iterations for the linear solver
linearsolver_maxiter = 20
// Set the time-stepper
timestepper=IMR
