##################
# Testcase 
##################
// Number of levels per subsystem
// These must match the Hamiltonian dimension defined in the python file.
nlevels = 3, 3
// Number of essential levels per subsystem (Default: Same as number of levels, comment out if not used). 
nessential = 2, 2
// Number of time steps 
ntime = 2000
// Time step size (ns. Units should align the system parameter units in the python Hamiltonian)
dt = 0.005
// Enable the python interface here, passing the name of the script that defines the  Hamiltonian terms. The script must be in working directory. No path can be added here (and no "./" in front!)
python_file = Hamiltonian.py
#python_file = none
// Fundamental transition frequencies (|0> to |1> transition) for each oscillator ("\omega_k", multiplying a_k^d a_k,  GHz, will be multiplied by 2*PI)
// If python interface enabled, those numbers will ignored since the Hamiltonian is read from the python script
transfreq = 4.0, 5.0 
// Self-kerr frequencies for each oscillator ("\xi_k", multiplying a_k^d a_k^d a_k a_k,  GHz, will be multiplied by 2*PI)
// If python interface enabled, those will ignored 
selfkerr = 0.2, 0.3
// Cross-kerr coupling frequencies for each oscillator coupling k<->l ("\xi_kl", multiplying a_k^d a_k a_l^d a_l, MHz, will be multiplied by 2*PI)
// Format: x = [x_01, x_02,...,x_12, x_13....] -> number of elements here should be (noscillators-1)*noscillators/2 !
// If python interface enabled, those numbers will ignored
crosskerr = 0.01
// Jaynes-Cummings coupling frequencies for each oscillator coupling k<->l ("J_kl", multiplying a_k^d a_l + a_k a_l^d, MHz, will be multiplied by 2*PI)
// Format Jkl = [J_01, J_02, ..., J12, J13, ...] -> number of elements are (noscillators-1)*noscillators/2
// Will be ignored if python interface enabled
Jkl = 0.01
// Rotational wave approximation frequencies for each subsystem  ("\omega_rot", MHz, will be multiplied by 2*PI)
// Note: The rotation of a target *gate* can be given separately with the "gate_rot_freq" option, see below.
// Will also be ignored if python interface enabled
rotfreq = 3.9, 4.7
// Lindblad collapse type: "none", "decay", "dephase" or "both"
// Choosing 'none' solves Schroedinger's equation for the state vector, any other choice solves Lindblad's equation for the density matrix
collapse_type = both
#collapse_type = none
// Time of decay collapse operation (T1) per oscillator (gamma_1 = 1/T_1). 
decay_time =  10000.0, 10000.0
#decay_time =  0.0, 0.0
// Time of dephase collapse operation (T2) per oscillator (gamma_2 = 1/T_2). 
dephase_time = 0.0, 0.0
// Specify the initial conditions: 
// "file, /path/to/file"  - read one specific initial condition from file (Format: one column of length 2N^2 containing vectorized density matrix, first real part, then imaginary part)
// "pure, <list, of, unit, vecs, per, oscillator>" - init with kronecker product of pure vectors, e.g. "pure, 1,0" sets the initial state |1><1| \otimes |0><0|
// "ensemble, <list, of, oscillator, IDs>" - ensemble state for the subsystems indicated by the list of oscillators, ground state for the other oscillators
// "diagonal, <list, of, oscillator, IDs>" - all unit vectors that correspond to the diagonal of the (full or reduced) density matrix for the subsystem defined by the list of oscillator IDs.
// "basis, <list, of, oscillator, IDs>" - basis for the (full or reduced) density matrix for the subsystem defined by the list of oscillator IDs.
// "3states"  - uses the three specific initial states from C. Koch's paper for gate optimization ("Optimal control theory for a unitary operation under dissipative evolution", New Journal of Physics, 2014)
// "Nplus1"   - N+1 initial conditions from C. Koch's paper for gate optimization ("Optimal control theory for a unitary operation under dissipative evolution", New Journal of Physics, 2014)
#initialcondition = basis, 0, 1
#initialcondition = diagonal, 0, 1
#initialcondition = file, ./initcond/alice_sumbasis.dat
#initialcondition = ensemble, 0
initialcondition = pure, 0, 0
#initialcondition = 3states
#initialcondition = Nplus1
// Apply a pi-pulse to oscillator <oscilID> from <tstart> to <tstop> using a control strength of <amp> rad/us. This ignores the code's control parameters inside [tstart,tstop], and instead applies the constant control amplitude |p+iq|=<amp> to oscillator <oscilID>, and zero control for all other oscillators.
// Format per pipulse: 4 values: <oscilID (int)>, <tstart (double)>, <tstop (double)>, <amp(double)>
// For more than one pipulse, just put them behind each other. I.e. number of elements here should be integer multiple of 4. For example either of the following lines:
apply_pipulse = 0, 1.0, 8.0, 0.2
#apply_pipulse = 0, 0.5, 0.604, 15.10381, 1, 0.7, 0.804, 15.10381

#######################
# Optimization options 
#######################
// Define the controllable segments for each oscillator. Format: <controltype>, <parameter>, <tstart>, <tstop>  where controltype is 'spline' or 'step'. If spline: parameter=<numberofsplines> is the number of splines. For step: parameter=<amplitude_1>, <amplitude_2>, <tramp>. And <tstart>,<tstop> are the time interval where this controltype is active. Multiple segments for an oscillator can be put behind each other, e.g. "spline, 10, 0.1, 0.2, step, 0.04, 0.03, 0.001, 0.3, 0.4
control_segments0 = spline, 35
control_segments1 = spline, 35
// Set the initial control parameter values for each oscillator. Give one option for each segmemt. Format: "type, parameter" where <type>='constant', 'random', or 'random_seed', or 'file', and <parameter> is either the max amplitude, or the parameter file name [Note: Reading the initialization from file applies to *all* subsystems, i.e. the file should contain *all* parameters for all oscillators]. Multiple segments are listed behind each other, e.g. constant, 3.0, random 0.11, constant 1.0
control_initialization0 = constant, 0.0
control_initialization1 = constant, 0.0
// Specify bounds for the control parameters for each oscillator. One double for each segment.
control_bounds0 = 1.0
control_bounds1 = 1.0
// Carrier wave frequencies. One line per oscillator 0..Q-1. (MHz, will be multiplied by 2*PI)
carrier_frequency0 = 0.0, -0.2
carrier_frequency1 = 0.0, -0.3
// Specify the optimization target state \rho(T):
// "gate, <type>" where <type> can be "cnot", "cqnot", "swap", swap0q", "xgate", "ygate", "zgate" or "hadamard": the target state is the gate-transformed initial conditions. 
// "pure, <m1>, <m2>, ... , <mQ>"  - prepare the pure state |m1 m2 m3 ... mQ>. Note: Each oscillators pure target state is separated by commas!
// "file, /path/to/file" - read a target density matrix from file (Format: one column of length 2N^2 containing the vectorized density matrix, first all real elements, then all imaginary elements)
optim_target = pure, 1,0
// Specify the objective function
// "Jfrobenius", "Jtrace", or "Jmeasure"
optim_objective = Jtrace
// If optimization target is a gate, specify the gate rotation frequencies (MHz, will be multiplied by 2*PI). By default, those are the rotational frequencies of the system, so commenting out this line ensures that gate rotation matches the rotational frame frequencies. Otherwise, they can be set differently here, e.g. 0.0, 0.0,... for Lab frame gate. 
// Format: one number per oscillator. If less numbers are given, the *last* one will be used to all remaining oscillators.
gate_rot_freq = 0.0, 0.0
// Weights for summing over initial conditions in objective function. Format: list of values separated by comma. If less values than initial conditions are given, the LAST values will be copied for the remaining initial conditions. 
optim_weights = 1.0
// Optimization stopping tolerance (absolute: ||G|| < atol )
optim_atol     = 1e-7
// Optimization stopping tolerance (relative: ||G||/||G0|| < rtol )
optim_rtol     = 1e-8
// Maximum number of optimization iterations
optim_maxiter = 200
// Coefficient (gamma_2) of Tikhonov regularization for the design variables (gamma_2/2 || design ||^2)
optim_regul   = 0.00001
// Coefficient (gamma_1) for adding integral penalty term (gamma_1 \int_0^T P(rho(t) dt )
optim_penalty = 0.0
// integral penalty parameter inside the weight in P(rho(t)) (gaussian variance a)
optim_penalty_param = 0.0

######################
# Output and runtypes
######################
// Directory for output files
datadir = ./data_out
// Specify the desired output for each oscillator, one line per oscillator. Format: list of either of the following options: 
//"expectedEnergy" - expected energy level for each time step, 
//"population" - population (diagonals of the reduced density matrix) at each time step
//"fullstate" - density matrix of the full system (can appear in any of the lines). WARNING: might result in HUGE output files. Use with care.
output0 = expectedEnergy, population, fullstate
output1 = expectedEnergy, population
// Output frequency in the time domain: write output every <num> time-step (num=1 writes every time step)
output_frequency = 1
// Frequency of writing output during optimization: write output every <num> optimization iterations. 
optim_monitor_frequency = 1
// Runtype options: "simulation" - runs a forward simulation only, "gradient" - forward simulation and gradient computation, or "optimization" - run an optimization
runtype = simulation
#runtype = gradient
// Use matrix free solver, instead of sparse matrix implementation.
// If the python interface is enabled, we can only use the sparse-matrix solver (so matfree=false)
usematfree = false
// Solver type for solving the linear system at each time step, eighter 'gmres' for using Petsc's GMRES solver (preferred), or 'neumann' for using Neumann series iterations
linearsolver_type = gmres
// Set maximum number of iterations for the linear solver
linearsolver_maxiter = 20

#################################################
# Parallel execution: 
# MAKE SURE THAT np_optim * np_init * np_petsc = size(MPI_COMM_WORLD) 
# and that np_init matches the chosen option for 'initialcondition'!! 
# Parallel petsc (np_petsc>1) works only with for the sparse-matrix solver.
# Currently: Leave np_optim=1
#################################################
// Number of processes for distrubuting the initial conditions (np_init) and optimization (np_optim). The remaining processors (=size(MPI_COMM_WORLD)/(npinit*npoptim) will be used to parallelize petsc. 
np_init = 1
np_optim = 1
