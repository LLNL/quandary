##################
# Testcase: IBM qudit 5 and qudit 6
##################
// Number of levels per oscillator (full system)
nlevels = 4, 4
// Number of essential levels per oscillators (this works 2 oscillators only)
nessential = 2, 2
// Number of time steps
ntime = 124561
// Time step size (ns)
dt = 0.00535384269
// Self- and cross-ker frequencies in the drift Hamiltonian ("\xi") for each oscillator and coupling (GHz, will be multiplied by 2*PI)
// Format: x = [xi_0, x_01, x_02,...,x_1, x_12, x_13....] -> number of elements here should be (noscillators+1)*noscillators/2 !
// For IBM coupling: xi_kl are the J_kl in IBM's Hamiltonian!
xi = 0.3114160171877561, 0.0028590049588239075, 0.3105363104958379
// Fundamental transition frequencies (|0> to |1> transition) for each oscillator ("\omega", GHz, will be multiplied by 2*PI)
transfreq = 4.79247565947243, 4.657243200469258
// Rotation wave approximation frequencies for each oscillator ("\omega_rot", GHz, will be multiplied by 2*PI)
rotfreq  = 4.72485942997, 4.72485942997
// Lindblad collapse type: "none", "decay", "dephase" or "both"
lindblad_type = both
// Collapse times T1, T2 per oscillator (gamma_l = 1/T_l for l=1,2). Format [T1_oscil1, T2_oscli1, T1_oscil2, T2_oscil2, ...]
#lindblad_collapsetime = 0.0, 0.0, 0.0, 0.0
lindblad_collapsetime = 123360.59727532006, 60107.91718742903, 113457.61304444564, 59042.26510788116
// Specify the initial conditions:
// "file, /path/to/file"  - read one specific initial condition from file (Format: one column of length 2N^2 containing vectorized density matrix, first real part, then imaginary part)
// "pure, <list, of, unit, vecs, per, oscillator>" - init with kronecker product of pure vectors, e.g. "pure, 1,0" sets the initial state |1><1| \otimes |0><0|
// "diagonal, <list, of, oscillator, IDs>" - all unit vectors that correspond to the diagonal of the (full or reduced) density matrix for the subsystem defined by the list of oscillator IDs.
// "basis, <list, of, oscillator, IDs>" - basis for the (full or reduced) density matrix for the subsystem defined by the list of oscillator IDs.
// "3states"  - uses the three specific initial states from C. Koch's paper for gate optimization
initialcondition = basis, 0,1
#initialcondition = diagonal, 0,1
#initialcondition = file, ./initcond/alice_sumbasis.dat
#initialcondition = pure, 1, 0
#initialcondition = 3states
// Apply a pi-pulse to oscillator <oscilID> from <tstart> to <tstop> using a control strength of <amp> rad/us. This ignores the code's control parameters inside [tstart,tstop], and instead applies the constant control amplitude |p+iq|=<amp> to oscillator <oscilID>, and zero control for all other oscillators.
// Format per pipulse: 4 values: <oscilID (int)>, <tstart (double)>, <tstop (double)>, <amp(double)>
// For more than one pipulse, just put them behind each other. I.e. number of elements here should be integer multiple of 4. For example either of the following lines:
#apply_pipulse = 0, 0.5, 0.604, 15.10381
#apply_pipulse = 0, 0.5, 0.604, 15.10381, 1, 0.7, 0.804, 15.10381

#######################
# Optimization options
#######################
// Number of spline basis functions per oscillator control (rule of thumb: 1 per 10ns)
nspline = 50
// Carrier wave frequencies. One line per oscillator 0..Q-1. (MHz, will be multiplied by 2*PI)
carrier_frequency0 = -6.7616229501586e-02,  6.7616229501586e-02, -3.7815253999742e-01, -2.4379978768617e-01
carrier_frequency1 = -6.7616229501586e-02,  6.7616229501586e-02, -3.7815253999742e-01, -2.4379978768617e-01
// Specify the objective function:
// "expectedEnergy" minimizes the expected energy levels of the (full or reduced) density matrix.
// "groundstate" compares (full or reduced) density matrix to groundstate density matrix in Frobenius norm
// "gate, <type>" where <type> can be "cnot", "xgate", "ygate", "zgate" or "hadamard": compares final state to gate-transformed initial conditions.
optim_objective = gate, swap
// Gate rotation frequencies (GHz)
gate_rot_freq = -0.0676162295, 0.0676162295
// IF objective_type is a 'gate': Specify the measure: Either "frobenius" for Frob-norm 1/2*||rho(T)-Vrho(0)V||^2, or "trace" for trace overlap 1-Tr(Vrho(0)V^d rho(T))
gate_measure = trace
// Specify the oscillator ID's that are considered by the objective function: "all" to consider full density matrix or a list of consecutive integers, e.g. "0,1,2" or "3,4" to consider a reduced matrix for those oscillators.
optim_oscillators = all
// Weights for summing over initial conditions in objective function. Format: list of values separated by comma. If less values than initial conditions are given, the LAST values will be copied for the remaining initial conditions.
optim_weights = 1.0, 1.0
// Initial control parameters: "constant" initializes with constant amplitudes, "random" initializes with random amplitudes (fixed seed), "random_seed" same but using a random seed, "/path/to/file/" reads initial paramters from file
optim_init = params_anders_sorted.dat
// Initial control parameter amplitudes for each oscillator, if constant initialization. If random initialization, these amplitudes are maximum bounds for the random number generator
optim_init_ampl = 0.002, 0.003
// Specify bounds for the absolute control function amplitudes per oscillator (rad/us)
optim_bounds = 100.0, 100.0
// Optimization stopping tolerance (absolute: ||G|| < atol )
optim_atol     = 1e-5
// Optimization stopping tolerance (relative: ||G||/||G0|| < rtol )
optim_rtol     = 1e-5
// Maximum number of optimization iterations
optim_maxiter = 100
// Coefficient of Tikhonov regularization for the design variables (gamma/2 || design ||^2)
optim_regul   = 0.0
// Coefficient for adding integral penalty term (gamma \int_0^T ||population(guardlevels)|| dt )
optim_penalty = 0.0
// integral penalty parameter inside w(t). Currently not in use.
optim_penalty_param = 0.0

######################
# Output and runtypes
######################
// Directory for output files
datadir = ./data_out
// Specify the desired output for each oscillator, one line per oscillator. Format: list of either of the following options:
//"expectedEnergy" - expected energy level for each time step,
//"population" - population (diagonals of the reduced density matrix) at each time step
//"fullstate" - density matrix of the full system (can appear in any of the lines). WARNING: might result in HUGE output files. Use with care.
output0 = expectedEnergy, population
output1 = expectedEnergy, population
// Output frequency in the time domain: write output every <num> time-step (num=1 writes every time step)
output_frequency = 10
// Frequency of writing output during optimization: write output every <num> optimization iterations
optim_monitor_frequency = 1
// Runtype options: "primal" - forward simulation only, "adjoint" - forward and backward, or "optimization" - run optimization
runtype = primal
// Use matrix free solver, instead of sparse matrix implementation. Currently implemented for 2 oscillators only.
usematfree = true
// Use Petsc's timestepper, or use home-brewed time stepper (preferred, implicit midpoint rule)
usepetscts = false
// Switch for monitoring Petc's timestepper
monitor = false
// Choose linear solver, eighter 'gmres' for using Petsc's GMRES solver (preferred), or 'neumann' for using Neumann series iterations to solve the linear system
linearsolver_type = gmres
// Set maximum number of iterations for the linear solver
linearsolver_maxiter = 20

#################################################
# Parallel execution (experimental):
# MAKE SURE THAT np_braid * np_init * np_petsc = size(MPI_COMM_WORLD)
# And that np_init matches the chosen option in 'initialcondition'
# parallel petsc works with usematfree=false only (even then some things might be broken. Please debug!)
#################################################
// Number of processes for distrubuting the initial conditions (np_init) and xbraid (np_braid). The remaining processors (=size(MPI_COMM_WORLD)/(npinit*npbraid) will be used to parallelize petsc.
np_init = 1
np_braid = 1

#######################
# XBraid options
#######################
// Maximum  number of time grid levels (maxlevels = 1 runs sequential simulation, i.e. no xbraid)
braid_maxlevels = 1
// Coarsening factor
braid_cfactor = 5
// Level of braid screen output. 0 - no output, 1 - convergence history, higher numbers: compare with xbraid doc
braid_printlevel = 1
// Maximum number of braid iterations per optimization cycle
braid_maxiter = 20
// Absolute stopping tolerance
braid_abstol = 1e-5
// Relative stopping tolerance
braid_reltol = 1e-4
// Turn on/off full multigrid cycle. This is costly, but convergence typically improves.
braid_fmg     = true
// Skip computation on first downcycle
braid_skip    = false
// Decide how often the state will be written to a file. 0 - never, 1 - once after each braid run // TODO: only after optimization finishes
braid_accesslevel = 1
