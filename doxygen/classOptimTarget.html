<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Quandary: OptimTarget Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Quandary
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classOptimTarget-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">OptimTarget Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Optimization target specification for quantum control.  
 <a href="classOptimTarget.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="optimtarget_8hpp_source.html">optimtarget.hpp</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for OptimTarget:</div>
<div class="dyncontent">
<div class="center"><img src="classOptimTarget__coll__graph.png" border="0" usemap="#aOptimTarget_coll__map" alt="Collaboration graph"/></div>
<map name="aOptimTarget_coll__map" id="aOptimTarget_coll__map">
<area shape="rect" title="Optimization target specification for quantum control." alt="" coords="5,93,108,119"/>
<area shape="rect" href="classGate.html" title="Base class for quantum gate operations." alt="" coords="30,5,83,31"/>
<area shape="poly" title=" " alt="" coords="59,45,59,93,54,93,54,45"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad4e0df2f3df0dfdf8ef8ecbfd299ca5a" id="r_ad4e0df2f3df0dfdf8ef8ecbfd299ca5a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOptimTarget.html#ad4e0df2f3df0dfdf8ef8ecbfd299ca5a">OptimTarget</a> ()</td></tr>
<tr class="separator:ad4e0df2f3df0dfdf8ef8ecbfd299ca5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdb2fc6a185481374dca4ff7ebe1694c" id="r_acdb2fc6a185481374dca4ff7ebe1694c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOptimTarget.html#acdb2fc6a185481374dca4ff7ebe1694c">OptimTarget</a> (std::vector&lt; std::string &gt; target_str, const std::string &amp;objective_str, std::vector&lt; std::string &gt; initcond_str, <a class="el" href="classMasterEq.html">MasterEq</a> *mastereq, double total_time, std::vector&lt; double &gt; read_gate_rot, Vec rho_t0, bool quietmode_)</td></tr>
<tr class="memdesc:acdb2fc6a185481374dca4ff7ebe1694c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor with full target specification.  <br /></td></tr>
<tr class="separator:acdb2fc6a185481374dca4ff7ebe1694c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acabdfafb394a6fba453729cad1d04435" id="r_acabdfafb394a6fba453729cad1d04435"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOptimTarget.html#acabdfafb394a6fba453729cad1d04435">~OptimTarget</a> ()</td></tr>
<tr class="separator:acabdfafb394a6fba453729cad1d04435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fc47d3feac302dfdb6bfb64fa56de68" id="r_a4fc47d3feac302dfdb6bfb64fa56de68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defs_8hpp.html#a0d59972970c855496cb4c877501e668f">TargetType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOptimTarget.html#a4fc47d3feac302dfdb6bfb64fa56de68">getTargetType</a> ()</td></tr>
<tr class="memdesc:a4fc47d3feac302dfdb6bfb64fa56de68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the target type.  <br /></td></tr>
<tr class="separator:a4fc47d3feac302dfdb6bfb64fa56de68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d6b9676ed98de1f16bd0f3abdb46c3d" id="r_a1d6b9676ed98de1f16bd0f3abdb46c3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defs_8hpp.html#a45660f9909187129a953fa05e664576e">ObjectiveType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOptimTarget.html#a1d6b9676ed98de1f16bd0f3abdb46c3d">getObjectiveType</a> ()</td></tr>
<tr class="memdesc:a1d6b9676ed98de1f16bd0f3abdb46c3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the objective function type.  <br /></td></tr>
<tr class="separator:a1d6b9676ed98de1f16bd0f3abdb46c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4af75b2ac84f07ef75c4634a051bdfb" id="r_ab4af75b2ac84f07ef75c4634a051bdfb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOptimTarget.html#ab4af75b2ac84f07ef75c4634a051bdfb">prepareInitialState</a> (const int iinit, const int ninit, const std::vector&lt; int &gt; &amp;nlevels, const std::vector&lt; int &gt; &amp;nessential, Vec rho0)</td></tr>
<tr class="memdesc:ab4af75b2ac84f07ef75c4634a051bdfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepares the initial condition state.  <br /></td></tr>
<tr class="separator:ab4af75b2ac84f07ef75c4634a051bdfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a537386e8b5a67bb7ad33010eb915af4c" id="r_a537386e8b5a67bb7ad33010eb915af4c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOptimTarget.html#a537386e8b5a67bb7ad33010eb915af4c">prepareTargetState</a> (const Vec rho)</td></tr>
<tr class="memdesc:a537386e8b5a67bb7ad33010eb915af4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepares the target state for gate optimization.  <br /></td></tr>
<tr class="separator:a537386e8b5a67bb7ad33010eb915af4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9599d91584bbdcd4a9e5133a60d97dc5" id="r_a9599d91584bbdcd4a9e5133a60d97dc5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOptimTarget.html#a9599d91584bbdcd4a9e5133a60d97dc5">evalJ</a> (const Vec state, double *J_re_ptr, double *J_im_ptr)</td></tr>
<tr class="memdesc:a9599d91584bbdcd4a9e5133a60d97dc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the final-time objective function measure \(J(\rho(T))\).  <br /></td></tr>
<tr class="separator:a9599d91584bbdcd4a9e5133a60d97dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeda8d95a617cfd015593eef8552c3841" id="r_aeda8d95a617cfd015593eef8552c3841"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOptimTarget.html#aeda8d95a617cfd015593eef8552c3841">evalJ_diff</a> (const Vec state, Vec statebar, const double J_re_bar, const double J_im_bar)</td></tr>
<tr class="memdesc:aeda8d95a617cfd015593eef8552c3841"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes derivative of the final-time objective function measure.  <br /></td></tr>
<tr class="separator:aeda8d95a617cfd015593eef8552c3841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a342568f752fd2898c6f27ecb41ea305a" id="r_a342568f752fd2898c6f27ecb41ea305a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOptimTarget.html#a342568f752fd2898c6f27ecb41ea305a">finalizeJ</a> (const double obj_cost_re, const double obj_cost_im)</td></tr>
<tr class="memdesc:a342568f752fd2898c6f27ecb41ea305a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalizes the objective function computation.  <br /></td></tr>
<tr class="separator:a342568f752fd2898c6f27ecb41ea305a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e626b91d25d4c4304fa624ac1f2ee20" id="r_a4e626b91d25d4c4304fa624ac1f2ee20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOptimTarget.html#a4e626b91d25d4c4304fa624ac1f2ee20">finalizeJ_diff</a> (const double obj_cost_re, const double obj_cost_im, double *obj_cost_re_bar, double *obj_cost_im_bar)</td></tr>
<tr class="memdesc:a4e626b91d25d4c4304fa624ac1f2ee20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derivative of objective function finalization.  <br /></td></tr>
<tr class="separator:a4e626b91d25d4c4304fa624ac1f2ee20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c987f7d018d49ca8a54e262b8d5151a" id="r_a3c987f7d018d49ca8a54e262b8d5151a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOptimTarget.html#a3c987f7d018d49ca8a54e262b8d5151a">FrobeniusDistance</a> (const Vec state)</td></tr>
<tr class="memdesc:a3c987f7d018d49ca8a54e262b8d5151a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes Frobenius distance between target and current state.  <br /></td></tr>
<tr class="separator:a3c987f7d018d49ca8a54e262b8d5151a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a944ded0e1eccab8295dcd9ab9f9934e8" id="r_a944ded0e1eccab8295dcd9ab9f9934e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOptimTarget.html#a944ded0e1eccab8295dcd9ab9f9934e8">FrobeniusDistance_diff</a> (const Vec state, Vec statebar, const double Jbar)</td></tr>
<tr class="memdesc:a944ded0e1eccab8295dcd9ab9f9934e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derivative of Frobenius distance computation.  <br /></td></tr>
<tr class="separator:a944ded0e1eccab8295dcd9ab9f9934e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcdb3bccc77da77d06e7c9a6f480e519" id="r_afcdb3bccc77da77d06e7c9a6f480e519"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOptimTarget.html#afcdb3bccc77da77d06e7c9a6f480e519">HilbertSchmidtOverlap</a> (const Vec state, const bool scalebypurity, double *HS_re_ptr, double *Hs_im_ptr)</td></tr>
<tr class="memdesc:afcdb3bccc77da77d06e7c9a6f480e519"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes Hilbert-Schmidt overlap between state and target.  <br /></td></tr>
<tr class="separator:afcdb3bccc77da77d06e7c9a6f480e519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3740ec8e0daf121b81957dd824545231" id="r_a3740ec8e0daf121b81957dd824545231"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOptimTarget.html#a3740ec8e0daf121b81957dd824545231">HilbertSchmidtOverlap_diff</a> (Vec statebar, bool scalebypurity, const double HS_re_bar, const double HS_im_bar)</td></tr>
<tr class="memdesc:a3740ec8e0daf121b81957dd824545231"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derivative of Hilbert-Schmidt overlap computation.  <br /></td></tr>
<tr class="separator:a3740ec8e0daf121b81957dd824545231"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ab1d22a530ba62865fb25f1a990e12455" id="r_ab1d22a530ba62865fb25f1a990e12455"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOptimTarget.html#ab1d22a530ba62865fb25f1a990e12455">dim</a></td></tr>
<tr class="memdesc:ab1d22a530ba62865fb25f1a990e12455"><td class="mdescLeft">&#160;</td><td class="mdescRight">State dimension of full vectorized system: N^2 if Lindblad, N if Schroedinger.  <br /></td></tr>
<tr class="separator:ab1d22a530ba62865fb25f1a990e12455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad28c5ca2c232911d3808bf8a4612eb93" id="r_ad28c5ca2c232911d3808bf8a4612eb93"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOptimTarget.html#ad28c5ca2c232911d3808bf8a4612eb93">dim_rho</a></td></tr>
<tr class="memdesc:ad28c5ca2c232911d3808bf8a4612eb93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dimension of Hilbert space = N.  <br /></td></tr>
<tr class="separator:ad28c5ca2c232911d3808bf8a4612eb93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2065f6575b1e93f9a992271673ff7a6c" id="r_a2065f6575b1e93f9a992271673ff7a6c"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOptimTarget.html#a2065f6575b1e93f9a992271673ff7a6c">dim_ess</a></td></tr>
<tr class="memdesc:a2065f6575b1e93f9a992271673ff7a6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dimension of essential level system = N_e.  <br /></td></tr>
<tr class="separator:a2065f6575b1e93f9a992271673ff7a6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f014cfafd676e826d877e95d42f68f1" id="r_a7f014cfafd676e826d877e95d42f68f1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOptimTarget.html#a7f014cfafd676e826d877e95d42f68f1">noscillators</a></td></tr>
<tr class="memdesc:a7f014cfafd676e826d877e95d42f68f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of oscillators in the system.  <br /></td></tr>
<tr class="separator:a7f014cfafd676e826d877e95d42f68f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44c54b6a658798cc964f4c46070a19c4" id="r_a44c54b6a658798cc964f4c46070a19c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defs_8hpp.html#a0d59972970c855496cb4c877501e668f">TargetType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOptimTarget.html#a44c54b6a658798cc964f4c46070a19c4">target_type</a></td></tr>
<tr class="memdesc:a44c54b6a658798cc964f4c46070a19c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of optimization target (pure state preparation or gate optimization)  <br /></td></tr>
<tr class="separator:a44c54b6a658798cc964f4c46070a19c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a177e47037e091e35c89a61261b5c3a70" id="r_a177e47037e091e35c89a61261b5c3a70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defs_8hpp.html#a45660f9909187129a953fa05e664576e">ObjectiveType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOptimTarget.html#a177e47037e091e35c89a61261b5c3a70">objective_type</a></td></tr>
<tr class="memdesc:a177e47037e091e35c89a61261b5c3a70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of objective function measure (Frobenius, trace, pure-state measure)  <br /></td></tr>
<tr class="separator:a177e47037e091e35c89a61261b5c3a70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a760721e590199816c6e78c0dd212fc47" id="r_a760721e590199816c6e78c0dd212fc47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGate.html">Gate</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOptimTarget.html#a760721e590199816c6e78c0dd212fc47">targetgate</a></td></tr>
<tr class="memdesc:a760721e590199816c6e78c0dd212fc47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to target gate (if gate optimization)  <br /></td></tr>
<tr class="separator:a760721e590199816c6e78c0dd212fc47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a821937fbbb90e0149ef0604e0296ded7" id="r_a821937fbbb90e0149ef0604e0296ded7"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOptimTarget.html#a821937fbbb90e0149ef0604e0296ded7">purity_rho0</a></td></tr>
<tr class="memdesc:a821937fbbb90e0149ef0604e0296ded7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Purity of initial state Tr(rho(0)^2)  <br /></td></tr>
<tr class="separator:a821937fbbb90e0149ef0604e0296ded7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a633585f6dccf774666142b3434063dee" id="r_a633585f6dccf774666142b3434063dee"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOptimTarget.html#a633585f6dccf774666142b3434063dee">purestateID</a></td></tr>
<tr class="memdesc:a633585f6dccf774666142b3434063dee"><td class="mdescLeft">&#160;</td><td class="mdescRight">For pure state preparation: integer m for preparing the target state \( e_m e_m^{\dagger}\).  <br /></td></tr>
<tr class="separator:a633585f6dccf774666142b3434063dee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f0dcc6280b4a0566551b5cee17233d5" id="r_a5f0dcc6280b4a0566551b5cee17233d5"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOptimTarget.html#a5f0dcc6280b4a0566551b5cee17233d5">target_filename</a></td></tr>
<tr class="memdesc:a5f0dcc6280b4a0566551b5cee17233d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filename if target state is read from file.  <br /></td></tr>
<tr class="separator:a5f0dcc6280b4a0566551b5cee17233d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fbf4a56a771afe523bd3722f29930dc" id="r_a8fbf4a56a771afe523bd3722f29930dc"><td class="memItemLeft" align="right" valign="top">Vec&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOptimTarget.html#a8fbf4a56a771afe523bd3722f29930dc">targetstate</a></td></tr>
<tr class="memdesc:a8fbf4a56a771afe523bd3722f29930dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage for the target state vector (NULL for pure states, \(V\rho V^\dagger\) for gates, density matrix from file)  <br /></td></tr>
<tr class="separator:a8fbf4a56a771afe523bd3722f29930dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ad253f14dc10cb6973c69a749e99a94" id="r_a9ad253f14dc10cb6973c69a749e99a94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defs_8hpp.html#a83753afdf4b4b0d70f2a478cfba82d35">InitialConditionType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOptimTarget.html#a9ad253f14dc10cb6973c69a749e99a94">initcond_type</a></td></tr>
<tr class="memdesc:a9ad253f14dc10cb6973c69a749e99a94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of initial conditions.  <br /></td></tr>
<tr class="separator:a9ad253f14dc10cb6973c69a749e99a94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e1ec452b0fe3e71285fc98b03fc54ff" id="r_a3e1ec452b0fe3e71285fc98b03fc54ff"><td class="memItemLeft" align="right" valign="top">std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOptimTarget.html#a3e1ec452b0fe3e71285fc98b03fc54ff">initcond_IDs</a></td></tr>
<tr class="memdesc:a3e1ec452b0fe3e71285fc98b03fc54ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integer list for pure-state initialization.  <br /></td></tr>
<tr class="separator:a3e1ec452b0fe3e71285fc98b03fc54ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b104e0388ba61c811a89101a1216a53" id="r_a2b104e0388ba61c811a89101a1216a53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defs_8hpp.html#a5e46e0fe90abc6230f71928a43849bd2">LindbladType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOptimTarget.html#a2b104e0388ba61c811a89101a1216a53">lindbladtype</a></td></tr>
<tr class="memdesc:a2b104e0388ba61c811a89101a1216a53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of Lindblad decoherence operators, or NONE for Schroedinger solver.  <br /></td></tr>
<tr class="separator:a2b104e0388ba61c811a89101a1216a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6060e7c4806b7d310f16b8cab58937c" id="r_ae6060e7c4806b7d310f16b8cab58937c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOptimTarget.html#ae6060e7c4806b7d310f16b8cab58937c">mpisize_petsc</a></td></tr>
<tr class="memdesc:ae6060e7c4806b7d310f16b8cab58937c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of PETSc communicator.  <br /></td></tr>
<tr class="separator:ae6060e7c4806b7d310f16b8cab58937c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7f248dd240b3811a38bca272da7579a" id="r_ad7f248dd240b3811a38bca272da7579a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOptimTarget.html#ad7f248dd240b3811a38bca272da7579a">mpirank_petsc</a></td></tr>
<tr class="memdesc:ad7f248dd240b3811a38bca272da7579a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rank of PETSc communicator.  <br /></td></tr>
<tr class="separator:ad7f248dd240b3811a38bca272da7579a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f579c8a1c55f82facfb21cd7193fb11" id="r_a0f579c8a1c55f82facfb21cd7193fb11"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOptimTarget.html#a0f579c8a1c55f82facfb21cd7193fb11">localsize_u</a></td></tr>
<tr class="memdesc:a0f579c8a1c55f82facfb21cd7193fb11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of local sub vector u or v in state x=[u,v].  <br /></td></tr>
<tr class="separator:a0f579c8a1c55f82facfb21cd7193fb11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac870ff2e6fb6930071019b2f83d62ce7" id="r_ac870ff2e6fb6930071019b2f83d62ce7"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOptimTarget.html#ac870ff2e6fb6930071019b2f83d62ce7">ilow</a></td></tr>
<tr class="memdesc:ac870ff2e6fb6930071019b2f83d62ce7"><td class="mdescLeft">&#160;</td><td class="mdescRight">First index of the local sub vector u,v.  <br /></td></tr>
<tr class="separator:ac870ff2e6fb6930071019b2f83d62ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cc067669446cb60e4b3ff04635a6fff" id="r_a3cc067669446cb60e4b3ff04635a6fff"><td class="memItemLeft" align="right" valign="top">PetscInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOptimTarget.html#a3cc067669446cb60e4b3ff04635a6fff">iupp</a></td></tr>
<tr class="memdesc:a3cc067669446cb60e4b3ff04635a6fff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Last index (+1) of the local sub vector u,v.  <br /></td></tr>
<tr class="separator:a3cc067669446cb60e4b3ff04635a6fff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09f7c5e3e0464e954c188719b1843458" id="r_a09f7c5e3e0464e954c188719b1843458"><td class="memItemLeft" align="right" valign="top">Vec&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOptimTarget.html#a09f7c5e3e0464e954c188719b1843458">aux</a></td></tr>
<tr class="memdesc:a09f7c5e3e0464e954c188719b1843458"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary vector for gate optimization objective computation.  <br /></td></tr>
<tr class="separator:a09f7c5e3e0464e954c188719b1843458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c36ccb6411cea9f218c853bced62fcb" id="r_a4c36ccb6411cea9f218c853bced62fcb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOptimTarget.html#a4c36ccb6411cea9f218c853bced62fcb">quietmode</a></td></tr>
<tr class="memdesc:a4c36ccb6411cea9f218c853bced62fcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag for quiet mode operation.  <br /></td></tr>
<tr class="separator:a4c36ccb6411cea9f218c853bced62fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Optimization target specification for quantum control. </p>
<p>This class manages the target specification for quantum optimal control problems, including gate optimization and pure state preparation. It handles target and initial state preparation and the evaluation of the final-time objective function measure.</p>
<p>Main functionality:</p><ul>
<li><a class="el" href="classOptimTarget.html#ab4af75b2ac84f07ef75c4634a051bdfb">prepareInitialState</a> prepares and returns the states at time t=0, depending on what the optimization target is</li>
<li><a class="el" href="classOptimTarget.html#a537386e8b5a67bb7ad33010eb915af4c">prepareTargetState</a> prepares and stores the corresponding target state for this initial state</li>
<li><a class="el" href="classOptimTarget.html#a9599d91584bbdcd4a9e5133a60d97dc5">evalJ</a> for computing the final-time objective function measure</li>
</ul>
<p>This class contains references to:</p><ul>
<li><a class="el" href="classGate.html">Gate</a> for evaluating the target state for quantum gate optimization </li>
</ul>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad4e0df2f3df0dfdf8ef8ecbfd299ca5a" name="ad4e0df2f3df0dfdf8ef8ecbfd299ca5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4e0df2f3df0dfdf8ef8ecbfd299ca5a">&#9670;&#160;</a></span>OptimTarget() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OptimTarget::OptimTarget </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acdb2fc6a185481374dca4ff7ebe1694c" name="acdb2fc6a185481374dca4ff7ebe1694c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdb2fc6a185481374dca4ff7ebe1694c">&#9670;&#160;</a></span>OptimTarget() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OptimTarget::OptimTarget </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>target_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>objective_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>initcond_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMasterEq.html">MasterEq</a> *&#160;</td>
          <td class="paramname"><em>mastereq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>total_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>read_gate_rot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>rho_t0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>quietmode_</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor with full target specification. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_str</td><td>Vector of strings specifying the target </td></tr>
    <tr><td class="paramname">objective_str</td><td>String specifying the objective function type </td></tr>
    <tr><td class="paramname">initcond_str</td><td>Vector of strings specifying initial conditions </td></tr>
    <tr><td class="paramname">mastereq</td><td>Pointer to master equation solver </td></tr>
    <tr><td class="paramname">total_time</td><td>Total evolution time </td></tr>
    <tr><td class="paramname">read_gate_rot</td><td><a class="el" href="classGate.html" title="Base class for quantum gate operations.">Gate</a> rotation parameters </td></tr>
    <tr><td class="paramname">rho_t0</td><td>Initial state vector </td></tr>
    <tr><td class="paramname">quietmode_</td><td>Flag for quiet operation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acabdfafb394a6fba453729cad1d04435" name="acabdfafb394a6fba453729cad1d04435"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acabdfafb394a6fba453729cad1d04435">&#9670;&#160;</a></span>~OptimTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OptimTarget::~OptimTarget </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9599d91584bbdcd4a9e5133a60d97dc5" name="a9599d91584bbdcd4a9e5133a60d97dc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9599d91584bbdcd4a9e5133a60d97dc5">&#9670;&#160;</a></span>evalJ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OptimTarget::evalJ </td>
          <td>(</td>
          <td class="paramtype">const Vec&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>J_re_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>J_im_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates the final-time objective function measure \(J(\rho(T))\). </p>
<p>The target state must be prepared and stored before calling this function. Returns both real and imaginary parts of the final-time measure. The imaginary part is generally zero except for Schroedinger solver with the trace objective function measure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>Current state vector </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">J_re_ptr</td><td>Pointer to store real part of objective </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">J_im_ptr</td><td>Pointer to store imaginary part of objective </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeda8d95a617cfd015593eef8552c3841" name="aeda8d95a617cfd015593eef8552c3841"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeda8d95a617cfd015593eef8552c3841">&#9670;&#160;</a></span>evalJ_diff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OptimTarget::evalJ_diff </td>
          <td>(</td>
          <td class="paramtype">const Vec&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>statebar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>J_re_bar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>J_im_bar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes derivative of the final-time objective function measure. </p>
<p>Updates the adjoint state vector for gradient computation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>Final-time state vector </td></tr>
    <tr><td class="paramname">statebar</td><td>Adjoint state vector to update </td></tr>
    <tr><td class="paramname">J_re_bar</td><td>Adjoint of real part of objective </td></tr>
    <tr><td class="paramname">J_im_bar</td><td>Adjoint of imaginary part of objective </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a342568f752fd2898c6f27ecb41ea305a" name="a342568f752fd2898c6f27ecb41ea305a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a342568f752fd2898c6f27ecb41ea305a">&#9670;&#160;</a></span>finalizeJ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OptimTarget::finalizeJ </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>obj_cost_re</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>obj_cost_im</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalizes the objective function computation. </p>
<p>Compute the infidelity (1-fidelity).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj_cost_re</td><td>Real part of objective cost </td></tr>
    <tr><td class="paramname">obj_cost_im</td><td>Imaginary part of objective cost </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double Final objective function value </dd></dl>

</div>
</div>
<a id="a4e626b91d25d4c4304fa624ac1f2ee20" name="a4e626b91d25d4c4304fa624ac1f2ee20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e626b91d25d4c4304fa624ac1f2ee20">&#9670;&#160;</a></span>finalizeJ_diff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OptimTarget::finalizeJ_diff </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>obj_cost_re</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>obj_cost_im</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>obj_cost_re_bar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>obj_cost_im_bar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Derivative of objective function finalization. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">obj_cost_re</td><td>Real part of objective cost </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">obj_cost_im</td><td>Imaginary part of objective cost </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">obj_cost_re_bar</td><td>Pointer to store adjoint of real part </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">obj_cost_im_bar</td><td>Pointer to store adjoint of imaginary part </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3c987f7d018d49ca8a54e262b8d5151a" name="a3c987f7d018d49ca8a54e262b8d5151a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c987f7d018d49ca8a54e262b8d5151a">&#9670;&#160;</a></span>FrobeniusDistance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OptimTarget::FrobeniusDistance </td>
          <td>(</td>
          <td class="paramtype">const Vec&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes Frobenius distance between target and current state. </p>
<p>Calculates \(F = 1/2 || \rho_{target} - \rho||^2_F\)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>Current state vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double Frobenius distance </dd></dl>

</div>
</div>
<a id="a944ded0e1eccab8295dcd9ab9f9934e8" name="a944ded0e1eccab8295dcd9ab9f9934e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a944ded0e1eccab8295dcd9ab9f9934e8">&#9670;&#160;</a></span>FrobeniusDistance_diff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OptimTarget::FrobeniusDistance_diff </td>
          <td>(</td>
          <td class="paramtype">const Vec&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>statebar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>Jbar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Derivative of Frobenius distance computation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>Current state vector </td></tr>
    <tr><td class="paramname">statebar</td><td>Adjoint state vector to update </td></tr>
    <tr><td class="paramname">Jbar</td><td>Adjoint seed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1d6b9676ed98de1f16bd0f3abdb46c3d" name="a1d6b9676ed98de1f16bd0f3abdb46c3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d6b9676ed98de1f16bd0f3abdb46c3d">&#9670;&#160;</a></span>getObjectiveType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8hpp.html#a45660f9909187129a953fa05e664576e">ObjectiveType</a> OptimTarget::getObjectiveType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the objective function type. </p>
<dl class="section return"><dt>Returns</dt><dd>ObjectiveType Type of objective function </dd></dl>

</div>
</div>
<a id="a4fc47d3feac302dfdb6bfb64fa56de68" name="a4fc47d3feac302dfdb6bfb64fa56de68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fc47d3feac302dfdb6bfb64fa56de68">&#9670;&#160;</a></span>getTargetType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8hpp.html#a0d59972970c855496cb4c877501e668f">TargetType</a> OptimTarget::getTargetType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the target type. </p>
<dl class="section return"><dt>Returns</dt><dd>TargetType Type of optimization target </dd></dl>

</div>
</div>
<a id="afcdb3bccc77da77d06e7c9a6f480e519" name="afcdb3bccc77da77d06e7c9a6f480e519"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcdb3bccc77da77d06e7c9a6f480e519">&#9670;&#160;</a></span>HilbertSchmidtOverlap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OptimTarget::HilbertSchmidtOverlap </td>
          <td>(</td>
          <td class="paramtype">const Vec&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>scalebypurity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>HS_re_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>Hs_im_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes Hilbert-Schmidt overlap between state and target. </p>
<p>Calculates \( Tr(\rho^\dagger \rho_{target})\), optionally scaled by the purity of the target state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>Current state vector </td></tr>
    <tr><td class="paramname">scalebypurity</td><td>Flag to scale by purity of target state </td></tr>
    <tr><td class="paramname">HS_re_ptr</td><td>Pointer to store real part of overlap </td></tr>
    <tr><td class="paramname">Hs_im_ptr</td><td>Pointer to store imaginary part of overlap </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3740ec8e0daf121b81957dd824545231" name="a3740ec8e0daf121b81957dd824545231"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3740ec8e0daf121b81957dd824545231">&#9670;&#160;</a></span>HilbertSchmidtOverlap_diff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OptimTarget::HilbertSchmidtOverlap_diff </td>
          <td>(</td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>statebar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>scalebypurity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>HS_re_bar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>HS_im_bar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Derivative of Hilbert-Schmidt overlap computation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">statebar</td><td>Adjoint state vector to update </td></tr>
    <tr><td class="paramname">scalebypurity</td><td>Flag to scale by purity of target state </td></tr>
    <tr><td class="paramname">HS_re_bar</td><td>Adjoint of real part of overlap </td></tr>
    <tr><td class="paramname">HS_im_bar</td><td>Adjoint of imaginary part of overlap </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab4af75b2ac84f07ef75c4634a051bdfb" name="ab4af75b2ac84f07ef75c4634a051bdfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4af75b2ac84f07ef75c4634a051bdfb">&#9670;&#160;</a></span>prepareInitialState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OptimTarget::prepareInitialState </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>iinit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>ninit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>nlevels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>nessential</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec&#160;</td>
          <td class="paramname"><em>rho0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepares the initial condition state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iinit</td><td>Index in processor range [rank * ninit_local .. (rank+1) * ninit_local - 1] </td></tr>
    <tr><td class="paramname">ninit</td><td>Total number of initial conditions </td></tr>
    <tr><td class="paramname">nlevels</td><td>Number of levels per oscillator </td></tr>
    <tr><td class="paramname">nessential</td><td>Number of essential levels per oscillator </td></tr>
    <tr><td class="paramname">rho0</td><td>Vector to store the initial condition </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int Identifier for this initial condition (element number in matrix vectorization) </dd></dl>

</div>
</div>
<a id="a537386e8b5a67bb7ad33010eb915af4c" name="a537386e8b5a67bb7ad33010eb915af4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a537386e8b5a67bb7ad33010eb915af4c">&#9670;&#160;</a></span>prepareTargetState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OptimTarget::prepareTargetState </td>
          <td>(</td>
          <td class="paramtype">const Vec&#160;</td>
          <td class="paramname"><em>rho</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepares the target state for gate optimization. </p>
<p>For gate optimization, computes the rotated target state \(V \rho V^{\dagger}\) for a given initial state \(\rho\) and stores it locally as a class member. Also stores the purity of \(rho\) needed for scaling the Hilbert-Schmidt overlap in the trace objective function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rho</td><td>Initial state vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a09f7c5e3e0464e954c188719b1843458" name="a09f7c5e3e0464e954c188719b1843458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09f7c5e3e0464e954c188719b1843458">&#9670;&#160;</a></span>aux</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vec OptimTarget::aux</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Auxiliary vector for gate optimization objective computation. </p>

</div>
</div>
<a id="ab1d22a530ba62865fb25f1a990e12455" name="ab1d22a530ba62865fb25f1a990e12455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1d22a530ba62865fb25f1a990e12455">&#9670;&#160;</a></span>dim</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt OptimTarget::dim</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>State dimension of full vectorized system: N^2 if Lindblad, N if Schroedinger. </p>

</div>
</div>
<a id="a2065f6575b1e93f9a992271673ff7a6c" name="a2065f6575b1e93f9a992271673ff7a6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2065f6575b1e93f9a992271673ff7a6c">&#9670;&#160;</a></span>dim_ess</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt OptimTarget::dim_ess</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dimension of essential level system = N_e. </p>

</div>
</div>
<a id="ad28c5ca2c232911d3808bf8a4612eb93" name="ad28c5ca2c232911d3808bf8a4612eb93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad28c5ca2c232911d3808bf8a4612eb93">&#9670;&#160;</a></span>dim_rho</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt OptimTarget::dim_rho</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dimension of Hilbert space = N. </p>

</div>
</div>
<a id="ac870ff2e6fb6930071019b2f83d62ce7" name="ac870ff2e6fb6930071019b2f83d62ce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac870ff2e6fb6930071019b2f83d62ce7">&#9670;&#160;</a></span>ilow</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt OptimTarget::ilow</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>First index of the local sub vector u,v. </p>

</div>
</div>
<a id="a3e1ec452b0fe3e71285fc98b03fc54ff" name="a3e1ec452b0fe3e71285fc98b03fc54ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e1ec452b0fe3e71285fc98b03fc54ff">&#9670;&#160;</a></span>initcond_IDs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;size_t&gt; OptimTarget::initcond_IDs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Integer list for pure-state initialization. </p>

</div>
</div>
<a id="a9ad253f14dc10cb6973c69a749e99a94" name="a9ad253f14dc10cb6973c69a749e99a94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ad253f14dc10cb6973c69a749e99a94">&#9670;&#160;</a></span>initcond_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8hpp.html#a83753afdf4b4b0d70f2a478cfba82d35">InitialConditionType</a> OptimTarget::initcond_type</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Type of initial conditions. </p>

</div>
</div>
<a id="a3cc067669446cb60e4b3ff04635a6fff" name="a3cc067669446cb60e4b3ff04635a6fff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cc067669446cb60e4b3ff04635a6fff">&#9670;&#160;</a></span>iupp</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt OptimTarget::iupp</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Last index (+1) of the local sub vector u,v. </p>

</div>
</div>
<a id="a2b104e0388ba61c811a89101a1216a53" name="a2b104e0388ba61c811a89101a1216a53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b104e0388ba61c811a89101a1216a53">&#9670;&#160;</a></span>lindbladtype</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8hpp.html#a5e46e0fe90abc6230f71928a43849bd2">LindbladType</a> OptimTarget::lindbladtype</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Type of Lindblad decoherence operators, or NONE for Schroedinger solver. </p>

</div>
</div>
<a id="a0f579c8a1c55f82facfb21cd7193fb11" name="a0f579c8a1c55f82facfb21cd7193fb11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f579c8a1c55f82facfb21cd7193fb11">&#9670;&#160;</a></span>localsize_u</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt OptimTarget::localsize_u</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Size of local sub vector u or v in state x=[u,v]. </p>

</div>
</div>
<a id="ad7f248dd240b3811a38bca272da7579a" name="ad7f248dd240b3811a38bca272da7579a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7f248dd240b3811a38bca272da7579a">&#9670;&#160;</a></span>mpirank_petsc</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int OptimTarget::mpirank_petsc</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rank of PETSc communicator. </p>

</div>
</div>
<a id="ae6060e7c4806b7d310f16b8cab58937c" name="ae6060e7c4806b7d310f16b8cab58937c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6060e7c4806b7d310f16b8cab58937c">&#9670;&#160;</a></span>mpisize_petsc</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int OptimTarget::mpisize_petsc</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Size of PETSc communicator. </p>

</div>
</div>
<a id="a7f014cfafd676e826d877e95d42f68f1" name="a7f014cfafd676e826d877e95d42f68f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f014cfafd676e826d877e95d42f68f1">&#9670;&#160;</a></span>noscillators</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int OptimTarget::noscillators</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of oscillators in the system. </p>

</div>
</div>
<a id="a177e47037e091e35c89a61261b5c3a70" name="a177e47037e091e35c89a61261b5c3a70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a177e47037e091e35c89a61261b5c3a70">&#9670;&#160;</a></span>objective_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8hpp.html#a45660f9909187129a953fa05e664576e">ObjectiveType</a> OptimTarget::objective_type</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Type of objective function measure (Frobenius, trace, pure-state measure) </p>

</div>
</div>
<a id="a633585f6dccf774666142b3434063dee" name="a633585f6dccf774666142b3434063dee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a633585f6dccf774666142b3434063dee">&#9670;&#160;</a></span>purestateID</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PetscInt OptimTarget::purestateID</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For pure state preparation: integer m for preparing the target state \( e_m e_m^{\dagger}\). </p>

</div>
</div>
<a id="a821937fbbb90e0149ef0604e0296ded7" name="a821937fbbb90e0149ef0604e0296ded7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a821937fbbb90e0149ef0604e0296ded7">&#9670;&#160;</a></span>purity_rho0</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double OptimTarget::purity_rho0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Purity of initial state Tr(rho(0)^2) </p>

</div>
</div>
<a id="a4c36ccb6411cea9f218c853bced62fcb" name="a4c36ccb6411cea9f218c853bced62fcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c36ccb6411cea9f218c853bced62fcb">&#9670;&#160;</a></span>quietmode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool OptimTarget::quietmode</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flag for quiet mode operation. </p>

</div>
</div>
<a id="a5f0dcc6280b4a0566551b5cee17233d5" name="a5f0dcc6280b4a0566551b5cee17233d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0dcc6280b4a0566551b5cee17233d5">&#9670;&#160;</a></span>target_filename</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string OptimTarget::target_filename</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Filename if target state is read from file. </p>

</div>
</div>
<a id="a44c54b6a658798cc964f4c46070a19c4" name="a44c54b6a658798cc964f4c46070a19c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44c54b6a658798cc964f4c46070a19c4">&#9670;&#160;</a></span>target_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8hpp.html#a0d59972970c855496cb4c877501e668f">TargetType</a> OptimTarget::target_type</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Type of optimization target (pure state preparation or gate optimization) </p>

</div>
</div>
<a id="a760721e590199816c6e78c0dd212fc47" name="a760721e590199816c6e78c0dd212fc47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a760721e590199816c6e78c0dd212fc47">&#9670;&#160;</a></span>targetgate</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGate.html">Gate</a>* OptimTarget::targetgate</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer to target gate (if gate optimization) </p>

</div>
</div>
<a id="a8fbf4a56a771afe523bd3722f29930dc" name="a8fbf4a56a771afe523bd3722f29930dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fbf4a56a771afe523bd3722f29930dc">&#9670;&#160;</a></span>targetstate</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vec OptimTarget::targetstate</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Storage for the target state vector (NULL for pure states, \(V\rho V^\dagger\) for gates, density matrix from file) </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/runner/work/quandary/quandary/include/<a class="el" href="optimtarget_8hpp_source.html">optimtarget.hpp</a></li>
<li>/home/runner/work/quandary/quandary/src/<a class="el" href="optimtarget_8cpp.html">optimtarget.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
