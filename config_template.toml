# ---------------------------------------------------------------
# -------------------------- System settings --------------------
# ---------------------------------------------------------------
[system]
# Number of levels per subsystem
nlevels = [2, 2]
# Number of essential levels per subsystem (Default: same as nlevels)
nessential = [2, 2]
# Number of time steps used for time-integration
ntime = 1000
# Time step size (ns). Determines final time: T=ntime*dt
dt = 0.1
# Fundamental transition frequencies (|0> to |1> transition) for each oscillator ("\omega_k", multiplying a_k^d a_k, GHz)
transfreq = [4.10595, 4.81526]
# Self-kerr frequencies for each oscillator ("\xi_k", multiplying a_k^d a_k^d a_k a_k, GHz)
selfkerr = [0.2198, 0.2252]
# Cross-kerr coupling frequencies for each oscillator coupling k<->l ("\xi_kl", multiplying a_k^d a_k a_l^d a_l, GHz).
# Format: xi_01, xi_02, xi03, ... ,xi_12, xi_13, ...
crosskerr = [0.1]
# Dipole-dipole coupling frequencies for each oscillator coupling k<->l ("J_kl", multiplying a_k^d a_l + a_k a_l^d, GHz).
# Format Jkl = J_01, J_02, ..., J12, J13, ...
Jkl = [0.0]
# Rotational wave approximation frequencies for each subsystem ("\omega_rot", GHz).
# Note: The target gate rotation can be specified separately with option "gate_rot_freq", see below.
rotfreq = [4.10595, 4.81526]
# Switch between Schroedinger and Lindblad solver. "none" solves Schroedinger solver (state vector dynamics),
# all other options solve Lindblads master equation (density matrix dynamics)
# Options: "none", "decay", "dephase", "both"
collapse_type = "none"
# collapse_type = "decay"
# collapse_type = "dephase"
# collapse_type = "both"
# Time of decay collapse operation (T1) per oscillator (gamma_1 = 1/T_1) (for Lindblad solver)
decay_time = [0.0, 0.0]
# Time of dephase collapse operation (T2) per oscillator (gamma_2 = 1/T_2) (for Lindblad solver)
dephase_time = [0.0, 0.0]

# Specify the initial conditions that are to be propagated
initial_condition = {type = "basis"}
# initial_condition = {type = "basis", oscIDs = [0, 1]}
# initial_condition = {type = "file", filename = "path/to/initial_condition.dat"}
# initial_condition = {type = "pure", levels = [1, 0]}
# initial_condition = {type = "diagonal", oscIDs = [0]}
# initial_condition = {type = "ensemble", oscIDs = [0, 1]}
# initial_condition = {type = "3states"}
# initial_condition = {type = "nplus1"}
# initial_condition = {type = "performance"}

# Apply a pi-pulse to oscillator <oscID> from <tstart> to <tstop> using a control strength of <amp> rad/ns.
# This ignores the codes control parameters inside [tstart,tstop], and instead applies the constant control
# amplitude |p+iq|=<amp> to oscillator <oscID>, and zero control for all other oscillators.
# For more than one pipulse, just repeat this block.
# [[system.apply_pipulse]]
# oscID = 0
# tstart = 0.5
# tstop = 0.604
# amp = 15.10381

# Optional: Read system Hamiltonian from file (default: none - use built-in analytical Hamiltonian)
# hamiltonian_file_Hsys = "/path/to/system_hamiltonian.dat"
# Optional: Read control Hamiltonian from file (default: none - use built-in analytical Hamiltonian)
# hamiltonian_file_Hc = "/path/to/control_hamiltonian.dat"

# ---------------------------------------------------------------
# ------------------- Optimization options ----------------------
# ---------------------------------------------------------------
[optimization]
# Decide whether control pulses should start and end at zero. Default: true.
control_enforceBC = false

# Control initialization options:
# Option 1: File initialization (applies to all oscillators)
# [[optimization.control_initialization]]
# type = "file"
# filename = "params.dat"

# Option 2: Per-oscillator initialization
# [[optimization.control_initialization]]
# oscID = 0
# type = "constant"
# amplitude = 0.1
# phase = 0.0
# [[optimization.control_initialization]]
# oscID = 1
# type = "random"
# amplitude = 0.2

# Optimization target_type options: "gate", "pure", or "file".
# Gate types: "cnot", "cqnot", "swap", "swap0q", "qft", "xgate", "ygate", "zgate", "hadamard"
optim_target = {target_type = "gate", gate_type = "cnot"}
# optim_target = {target_type = "gate", gate_type = "file", gate_file = "/path/to/target_gate.dat"}
# optim_target = {target_type = "pure", levels = [0, 0]}
# optim_target = {target_type = "file", filename = "/path/to/target_state.dat"}

# Frequency of rotation of the target gate, for each oscillator (GHz). Default: 0.0
# gate_rot_freq = [0.0, 0.0]

# Objective function measure options: "Jtrace", "Jfrobenius", "Jmeasure"
optim_objective = "Jtrace"

# Weights for summing up the objective function (beta_i).
# If fewer numbers than oscillators are given, the last one will be propagated to the remaining ones.
optim_weights = [1.0]
# optim_weights = [0.5, 0.5]

# Optimization stopping tolerance based on gradient norm (absolute: ||G|| < atol)
optim_atol = 1e-7
# Optimization stopping tolerance based on gradient norm (relative: ||G||/||G0|| < rtol)
optim_rtol = 1e-8
# Optimization stopping criterion based on the final time cost (absolute: J(T) < ftol)
optim_ftol = 1e-5
# Optimization stopping criterion based on the infidelity (absolute: 1-Favg < inf_tol)
optim_inftol = 1e-5
# Maximum number of optimization iterations
optim_maxiter = 200
# Coefficient (gamma_1) of Tikhonov regularization for the design variables (gamma_1/2 || design ||^2)
optim_regul = 0.00001
# Coefficient (gamma_2) for adding first integral penalty term (gamma_1 âˆ«_0^T P(rho(t) dt )
optim_penalty = 0.0
# integral penalty parameter inside the weight in P(rho(t)) (gaussian variance a)
optim_penalty_param = 0.0
# Coefficient (gamma_3) for penalizing the integral of the second derivative of state populations
# (gamma_3 \int_0^T d^2/dt^2(Pop(rho)) dt )
optim_penalty_dpdm = 0.0
# Coefficient (gamma_4) for penalizing the control pulse energy integral (gamma_4 \int_0^T p^2 + q^2 dt )
optim_penalty_energy = 0.0
# Coefficient (gamma_5) for penalizing variations in control amplitudes.
# Only used for piece-wise constant control parameterizations (spline0)
optim_penalty_variation = 0.0
# Switch to use Tikhonov regularization with ||x - x_0||^2 instead of ||x||^2
optim_regul_tik0 = false

# Define the controllable segments for each oscillator and the type of parameterization.
# Multiple of these blocks can be defined.
# Available control types:
# "spline" - 2nd order B-spline basis functions (recommended)
# "spline0" - piecewise constant control parameterization (0th order B-splines)
# "spline_amplitude" - amplitude-only parameterization
# "step" - step function control
[[optimization.control_segments]]
oscID = 0
type = "spline"
num = 150
# tstart = 0.0  # optional, defaults to 0.0
# tstop = 100.0  # optional, defaults to ntime * dt

[[optimization.control_segments]]
oscID = 1
type = "spline"
num = 150

# [[optimization.control_segments]]
# oscID = 0
# type = "spline0"
# num = 300

# [[optimization.control_segments]]
# oscID = 0
# type = "spline_amplitude"
# num = 150
# scaling = 1.0

# [[optimization.control_segments]]
# oscID = 0
# type = "step"
# step_amp1 = 0.1
# step_amp2 = 0.2
# tramp = 0.3
# tstart = 0.0  # optional
# tstop = 100.0  # optional

# Set the initial control pulse parameters (GHz). One entry for each segment.
# Options: "constant" with amplitude and optional phase, "random" with amplitude and optional phase
[[optimization.control_initialization]]
oscID = 0
type = "constant"
amplitude = 0.005
# phase = 0.0  # optional, defaults to 0.0

[[optimization.control_initialization]]
oscID = 1
type = "constant"
amplitude = 0.005

# [[optimization.control_initialization]]
# oscID = 0
# type = "random"
# amplitude = 0.005

# Maximum amplitude bound for the control pulses for each oscillator (GHz). One entry for each segment.
[[optimization.control_bounds]]
oscID = 0
values = [0.008]

[[optimization.control_bounds]]
oscID = 1
values = [0.008]

# Carrier wave frequencies for each oscillator 0..Q-1. (GHz)
[[optimization.carrier_frequency]]
oscID = 0
values = [0.0, -0.2198, -0.1]

[[optimization.carrier_frequency]]
oscID = 1
values = [0.0, -0.2252, -0.1]

# ---------------------------------------------------------------
# ------------------- Output and runtypes ----------------------
# ---------------------------------------------------------------
[output]
# Directory for output files
datadir = "./data_out"

# Output frequency in the time domain: write output every <num> time-step
output_frequency = 1
# Frequency of writing output during optimization: write output every <num> optimization iterations
optim_monitor_frequency = 1
# Runtype options:
# "simulation" - a forward simulation only
# "gradient" - forward simulation and backward simulation
# "optimization" - a full optimization cycle
# "evalControls" - Only evaluates the current control pulses (no simulation)
# "none" - Don't run anything
runtype = "optimization"
# Use matrix free solver, instead of sparse matrix implementation. Only available for 2,3,4, or 5 oscillators.
usematfree = true
# Solver type for solving the linear system at each time step: "gmres", "neumann"
linearsolver_type = "gmres"
# Set maximum number of iterations for the linear solver
linearsolver_maxiter = 20
# Switch the time-stepping algorithm. Currently available:
# "IMR" - Implicit Midpoint Rule (IMR) of 2nd order,
# "IMR4" - Compositional IMR of order 2 using 3 stages,
# "IMR8" - Compositional IMR of order 8 using 15 stages,
# "EE" - Explicit Euler (EE) of 1st order, (for debugging only)
timestepper = "IMR"
# For reproducability, one can choose to set a fixed seed for the random number generator. Comment out, or set negative if seed should be random (non-reproducable)
rand_seed = 1234

# Specify the desired output for each oscillator. Format: list of either of the following options:
# "expectedEnergy" - time evolution of the expected energy level for this oscillator (expected energy of the reduced density matrix)
# "expectedEnergyComposite" - time evolution of expected energy level of the full-dimensional composite system
# "population" - time evolution of the energy level populations (probabilities) for this oscillator (diagonals of the reduced density matrix)
# "populationComposite" - time evolution of the energy level population (probabilities) for the full-dimensional composite system
# "fullstate" - time-evolution of the full state of the composite system (full density matrix, or state vector)
# (note: 'fullstate' can appear in *any* of the lines). WARNING: This might result in *huge* output files! Use with care.
[[output.write]]
oscID = 0
type = ["population", "expectedEnergy"]

[[output.write]]
oscID = 1
type = ["population", "expectedEnergy"]
